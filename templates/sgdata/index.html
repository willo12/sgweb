<!DOCTYPE html>
{% load static %}


<html lang="en">
    <head>
        
        <meta charset="utf-8" name="viewport" content="initial-scale=1.0, user-scalable=no"/>
  
  <!--      
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
 <script type="text/javascript" src="https://raw.github.com/jasondavies/conrec.js/master/conrec.js"></script>
	<script src="https://raw.github.com/d3/d3-plugins/master/geom/contour/contour.js"></script>
 -->

        <script src="{% static "js/d3.v3.min.js" %}">  </script> 
        <script src="{% static "js/conrec.js" %}">  </script>
        <script src="{% static "js/contour.js" %}">  </script> 
        <script src="{% static "js/jquery-2.1.1.min.js" %}">  </script>

        <style type="text/css">
            h1 {
            	font-family: sans-serif;
            	color: lime;
            }
        </style>

        <style type="text/css">
            .my_axis path,
            .my_axis line {
                fill: none;
                stroke: black;
                shape-rendering: crispEdges;
            }

            .my_axis text {
                font-family: sans-serif;
                font-size: 11px;
            }

            .my_colorbar text {
                font-family: sans-serif;
                font-size: 11px;
            }


            .my_flabel text {
                font-family: sans-serif;
                font-size: 13px;
            }

            .my_clabel text {
                font-family: sans-serif;
                font-size: 12px;
            }
      
.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}      
        </style>

        <title>This is my page</title>
    
    </head>
    <body>
        <h1>Data </h1>
   
 
    
        <script type="text/javascript">

var w=500,
    h=300,
    wcb=50,
    padding=40;

                      
var div=d3.select("body")
          .append("div")
          .attr("id","yo")

var svg=div.append("svg")
              .attr("width",w)
              .attr("height",h)
              .attr("id","yo_svg")

var url

// create dropdown list with field names
//d3.json('/sgdata/projects/my_project/DPO/',function(data){
//    div.append("select")
//       .attr("id","varsel")
//       .attr("name","vars")
//       .on("change", function(){
//          url=prep_url(this.value);
//          div.selectAll(".tempbut").remove(); 
//          div.selectAll(".cyclebut").remove();
//          svg.selectAll(".my_pcolor").remove();
//         svg.selectAll(".my_colorbar").remove();
//          svg.selectAll(".my_flabel").remove();
//          svg.selectAll(".my_contplot").remove();
//          svg.selectAll(".my_clabel").remove();

//          d3.json(url,function(data){dimdesp(div,data)})
//        })
//       .selectAll("option")
//       .data(data.vars)
//       .enter()
//       .append("option")
//       .text(function(d){return d})
//       .attr("value",function(d){return d})
//});

url=prep_url("A_sat/ops/?ops=MeanX")
d3.json(url,function(data){dimdesp(div,data)})
       

//div.append("button")
//   .attr("id","but1")
//   .text("data")
    //   .on("click",function(d){url=prep_url('A_sat');d3.json(url,function(data){handle_data(div,data,url)})})

//   .on("click",function(d){url=prep_url('O_temp');d3.json(url,function(data){rha(div,data)})})

 //   .on("click",function(d){url=prep_url('A_sat');d3.json(url,function(data){rha(div,data)})})

 //  .on("click",function(d){url=prep_url('O_velY/ops/?ops=PrimZ*IntegX');d3.json(url,function(data){handle_data(div,data,url)})})

//  .on("click",function(d){url=prep_url('O_velX/method/mean/?args=Z');d3.json(url,function(data){handle_data(div,data,url)})})


function handle_more_data(axob,data){

    data = handle_nan(data);
    data.lname ='' // block out title as this is a secondary plot

    return plot_contour(axob.svg,d3.transpose(data.value),data.coord0,data.coord1,axob.xScale,axob.yScale,data.m,data.M,12, false, true);
}

function handle_nan2D(value){

    var row
    for (var i=0;i<value.length;i++){
        row=value[i]
        for (var j=0;j<row.length;j++){
            if (row[j] < -8e20){
   
   // this needs to be some other value for d3.max and d3.min to work.
                row[j] = NaN
            }
        }
    }
    return value
}

function handle_nan(data){
    if (data.ndim==2){
        data.value=handle_nan2D(data.value)        
    }else{
        for (var i=0;i<data.slices.length;i++){
            data.slices[i].value=handle_nan2D(data.slices[i].value);
        }    
    }
    return data
}


function dimdesp(div,data){
    
    if (data.ndim>1){
        rha(div,data)
  
    }else {
        console.log('1D')
        handle1D(div,data)
    }
}

function handle1D(div,data){

    svg=div.selectAll("svg")


var axob=prep_axes1D(div, data,true,true,-1)
    elms=display1D(axob,data)  
}

function rha(div,data){
     
    // handle 2D and 3D fields

    console.log("rha")


    var svg=div.selectAll("svg")
    data = handle_nan(data)
    
    var wcb=50,
    padding=40;

    // calculate scales
  
    if (data.ndim==3){
        // this puts the axes on the figure AND returns axob
        axob=prep_axes(div, data.slices[0],padding,wcb,true,true,-1)

        addcycler(axob,data,"button",display2D)
    }else if (data.ndim==2){
        axob=prep_axes(div, data,padding,wcb,true,true,-1)
       
        elms = display2D(axob,data)
    }
 //   console.log('over here')
}




function display1D(axob,data){
    var elms=[],
        but

    elms = elms.concat(doPlot(axob,data))

    but=axob.div.append("button")
        but.attr("id","change_field")
           .attr("class","chbut")
            .text("change field")
            .on("click",function(d){
                
   d3.json(prep_url("F_precip/ops/?ops=MeanX"),function(data){addtoggle(axob,data,"button",doPlotu,"F_precip off","F_precip","click")})
             })



    but=axob.div.append("button")
        but.attr("id","extra_field")
           .attr("class","tempbut")
            .text("extra field")
            .on("click",function(d){
                
   d3.json(prep_url("A_slat/ops/?ops=MeanX"),function(data){addtoggle(axob,data,"button",doPlot,"A_slat off","A_slat","click")})
             })


    return elms
}



function display2D(axob,data){
    var elms=[],
        but

    elms = elms.concat(doPcolor(axob,data))

// element w=handle_more_data(axob,data) is removed again with w.remove()

    elms = elms.concat(addtoggle(axob,data,"button",handle_more_data,"conts off","conts","click"))

    but=axob.div.append("button")
        but.attr("id","extra_field")
           .attr("class","tempbut")
            .text("extra field")
            .on("click",function(d){
   d3.json(prep_url('O_psi'),function(data){addtoggle(axob,data,"button",handle_more_data,"psi off","psi","click")})
             })



 //


//d3.json(prep_url('G_kmt'),function(data){addtoggle(axob,data,div,"button",my_kmt,"geog off","geography","click")})


//d3.json(prep_url('O_psi'),function(data){addtoggle(axob,data,div,"button",handle_more_data,"psi off","psi","click")})

    return elms
}



function toggle(w,axob,data,but,func,onms,offms){

    if (w==false){
        but.text(onms)
        return func(axob,data);
    }else{
        w.remove()
        but.text(offms)
        return false
    }    
};

function addtoggle(axob,data,tag,func,onms,offms,event){
    // adds interactive element to toggle content of div

    var w,
        but  // interactive element handle
    // data available in namespace
 //   var offms="contours",
 //       onms="remove conts";
    but=axob.div.append(tag)
            .attr("class","tempbut")
    but.attr("id",onms+offms)
        .text(offms)
        .on(event,function(d){
            // need to wrap toggle var w inside here:
            w=toggle(false,axob,data,but,func,onms,offms)
            
            but.on("click",function(d){
                w=toggle(w,axob,data,but,func,onms,offms)   
            });
         })

    return [but]
}


function expsel1D(axob,data,tag,func){
    // select exp for 1D graph and add to existing data and updates plot
    // tag is usually "button"
    // 

}

function remhandles(handles){
    for (var i=0;i<handles.length;i++){
        handles[i].remove()
    }
}

function cycler(w,wmax,axob,data,but,func){

    w=(w+1)%wmax

    but.text(data.scoord[w])
    return [w,func(axob,data.slices[w])]

};


function addcycler(axob,data,tag,func){
   // adds an element such as button to cycle through 3D field 
   // tag is usually "button"
    var w,
        clr,
        wmax=data.slices.length,
        but

    but=axob.div.append(tag)
    but.attr("id","cycler"+data.name)
        .attr("class","cyclebut")
        .text("cycle from "+ data.scoord[0])
 

            // need to wrap cycler var w inside here:
            clr=cycler(0,wmax,axob,data,but,func)
            w=clr[0]

            but.on("click",function(d){
 
                remhandles(clr[1])
                // unfortunate hack:
                axob.svg.selectAll(".my_contplot").remove()
                axob.svg.selectAll(".my_clabel").remove()
                axob.div.selectAll(".tempbut").remove()

                clr=cycler(w,wmax,axob,data,but,func);
                w=clr[0]  
               
            });

}



function my_kmt(axob,data){

    data.value = handle_nan(data.value);
    data.lname =''


    var w=axob.svg.attr("width")
    var h=axob.svg.attr("height")
 
    var wcb=50,
        padding=40;
     
    return plot_contour(axob.svg,d3.transpose(data.value),data.coord0,data.coord1,axob.xScale,axob.yScale,data.m,data.M,12, [0.5], false);
};


function doPlot(axob,data){
 
// cast data to be used in plot
var lineData=data2lines(data,axob.xScale,axob.yScale)

var plt=plot(axob.svg,lineData)

return plt
  
};

function doPlotu(axob,data){
   // update existing plot

    // prepare test data
 //   data.M = 1.5*data.M;

    // update the axes and obtain updated scales
    axob=prep_axes1Du(axob,div, data,true,true,-1)

// cast data to be used in plot. lineData encodes xScale, yScale
    var lineData=data2lines(data,axob.xScale,axob.yScale)

    var plt=plotu(axob.svg.selectAll(".line"),lineData)

    return plt
};


function doPcolor(axob,data){
 
    // cast data as tuples to be used in pcolor
    tuples = data2rectangles(data,axob.xScale,axob.yScale)

    var pclr=pcolor(axob.svg,tuples,data.m,data.M,24,'standard')

    var cbar=colorbar(axob.svg,data.m,data.M,30, axob.wcb,axob.padding,data.units,colours);

    return [pclr,cbar]             
};

function plot(svg,lineData){
    // expects data to be either an array of numbers
    // or an array of such arrays (multiple curves)

 // line plotting

// function used to draw lines
    var lineFunc = d3.svg.line()
                        .x(function(d) {
                            return d.x;
                        })
                        .y(function(d) {
                            return d.y;
                        })
                        .interpolate('linear');

    plt = svg.append("g")
              .attr("class","my_plot")

// plot one or more lines, using lineFunc
 
   
        plt.append('svg:path')
          .attr('class', 'line')
          .attr('d', lineFunc(lineData))
  
    return plt
}





function plotu(plt,lineData){
    // expects data to be either an array of numbers
    // or an array of such arrays (multiple curves)

 // line plotting

// function used to draw lines
    var lineFunc = d3.svg.line()
                        .x(function(d) {
                            return d.x;
                        })
                        .y(function(d) {
                            return d.y;
                        })
                        .interpolate('linear');

 //   plt = svg.append("g")
 //             .attr("class","my_plot")

// plot one or more lines, using lineFunc
 
   
        plt.transition()
        .duration(1000)
        .attr('d', lineFunc(lineData))
  
    return plt
}





function prep_url(varname){
    return '/sgdata/my_project/DPO/' + varname
}


//svg, data.coord0_edges,data.coord1_edges,data.m,data.M,padding,wcb,true,true,data.units,data.coord1_lname,data.coord0_lname,data.lname,-1

function prep_axes1Du(axob,div, data,xax,yax,i){
    // prepares and plots updated axes

    // for each of the following statements find an update equiv

    
    var My = data.M;
    var my = data.m;
    var Mx = d3.max(data.coord0);
    var mx = d3.min(data.coord0);

    var svg=div.selectAll("svg")

    var w=svg.attr("width"),
        h=svg.attr("height"),

        units=data.units,
        xlabel=data.coord0_lname,    
        ylabel=units,
        title=data.lname;
 
    if (i >-1){
        title =  ' ('+String.fromCharCode(97+i) +') '+title
    }

var haxes=svg.select(".my_plot_axes")
             


var htitle=haxes.selectAll("my_plot_title")
      .attr("class", "my_axis")
      .attr("text-anchor", "start")
      .attr("x", padding  )
      .attr("y", 25 )
      .text(title);

var MARGINS = {
        top: 30,
        right: 20,
        bottom: 30,
        left: 50
    }

var xScale=axob.xScale
var yScale=axob.yScale

xScale.domain([mx,Mx])
yScale.domain([my, My])

if (xax){ 
var hxlabel=false    
//var hxlabel=haxes.append("g")
//  .attr("class", "my_flabel")
//.append("text")
//      .attr("class", "x label")
//      .attr("class", "my_axis")
//      .attr("text-anchor", "end")
//      .attr("x", w- MARGINS.right)
//      .attr("y", h )
//      .text(xlabel);

    var xAxis = d3.svg.axis()
                 .scale(xScale)
                 .tickSize(5)
                 .tickSubdivide(true);

haxes.select('.my_x_axis')
  .transition()
  .duration(1000)
  .call(xAxis);
}else{
    var hxlabel=false
    var xAxis=false 
}

if (yax){
var hylabel=haxes.append("g")
//  .attr("class", "my_flabel")
//      .append("text")
//      .attr("class", "y label")
//      .attr("transform", "rotate(-90)")
//      .attr("y", 6)
//      .attr("x", -26)
//      .attr("dy", ".71em")
//      .style("text-anchor", "end")
//      .text(ylabel);

    var yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(5)
      .orient('left')
      .tickSubdivide(true);

haxes.selectAll(".my_y_axis")
  .transition()
  .duration(1000)
  .call(yAxis);

//haxes.append('svg:g')
//  .attr('class', "my_y_axis")
//  .attr("class", "my_axis")
//  .attr('transform', 'translate(' + (MARGINS.left) + ',0)')
//  .call(yAxis);

} else{
    var hylabel=false
    var yAxis=false
}   


    return {svg:svg,div:div,haxes:haxes,xScale:xScale,yScale:yScale,hxlabel:hxlabel,hylabel:hylabel,htitle:htitle,i:i}





}

function prep_axes1D(div, data,xax,yax,i){


    var My = data.M;
    var my = data.m;
    var Mx = d3.max(data.coord0);
    var mx = d3.min(data.coord0);

    var svg=div.selectAll("svg")

    var w=svg.attr("width"),
        h=svg.attr("height"),

        units=data.units,
        xlabel=data.coord0_lname,    
        ylabel=units,
        title=data.lname;
 
    if (i >-1){
        title =  ' ('+String.fromCharCode(97+i) +') '+title
    }

var haxes=svg.append("g")
             .attr("class","my_flabel my_plot_axes")
            

var htitle=haxes.append("g")
  .attr("class", "my_flabel")
.append("text")
//      .attr("class", "x label")
      .attr("class", "my_axis my_plot_title")
      
      .attr("text-anchor", "start")
      .attr("x", padding  )
      .attr("y", 25 )
      .text(title);

    var MARGINS = {
        top: 30,
        right: 20,
        bottom: 30,
        left: 50
    },
    xScale = d3.scale.linear().range([MARGINS.left, w - MARGINS.right]).domain([mx,Mx]),
    yScale = d3.scale.linear().range([h - MARGINS.top, MARGINS.bottom]).domain([my, My]);

if (xax){ 
    var hxlabel=haxes.append("g")
      .attr("class", "my_flabel")
      .append("text")
          .attr("class", "x label my_axis")
          
          .attr("text-anchor", "end")
          .attr("x", w- MARGINS.right)
          .attr("y", h )
          .text(xlabel);

    var xAxis = d3.svg.axis()
                 .scale(xScale)
                 .tickSize(5)
                 .tickSubdivide(true);

haxes.append('g')
  .attr('class', "my_x_axis my_axis")

  .attr('transform', 'translate(0,' + (h - MARGINS.bottom) + ')')
  .call(xAxis);
}else{
    var hxlabel=false
    var xAxis=false 
}

if (yax){
var hylabel=haxes.append("g")
  .attr("class", "my_flabel")
      .append("text")
      .attr("class", "y label")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("x", -26)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(ylabel);

    var yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(5)
      .orient('left')
      .tickSubdivide(true);

haxes.append('g')
  .attr('class', "my_y_axis my_axis")
  
  .attr('transform', 'translate(' + (MARGINS.left) + ',0)')
  .call(yAxis);
} else{
    var hylabel=false
    var yAxis=false
}   


    return {svg:svg,div:div,haxes:haxes,xScale:xScale,yScale:yScale,hxlabel:hxlabel,hylabel:hylabel,htitle:htitle,i:i}

}


function prep_axes(div, data,padding,wcb,xax,yax,i){
    // add labels and axes
    // create axes object axob containing information about labels and axes, including handles to entire label set and subsets

    var svg=div.selectAll("svg")

    var ycoord_edges=data.coord0_edges,
        xcoord_edges=data.coord1_edges,
        m=data.m,
        M=data.M,
        units=data.units,
        xlabel=data.coord1_lname,    
        ylabel=data.coord0_lname,
        title=data.lname;

    var w=svg.attr("width"),
        h=svg.attr("height");
        
    if (i >-1){
        title =  ' ('+String.fromCharCode(97+i) +') '+title

    }

    var haxes=svg.append("g")
             .attr("class","my_flabel")

var htitle=haxes.append("g")
  .attr("class", "my_flabel")
.append("text")
//      .attr("class", "x label")
      .attr("class", "my_axis")
      .attr("text-anchor", "start")
      .attr("x", padding  )
      .attr("y", 25 )
      .text(title);



    // contains array of (y,x,dy,dx,value)

 //    colours = make_cmap('standard',m,M,num_cont);

    var size_y = ycoord_edges.length-1,
        size_x = xcoord_edges.length-1
    
    
    var xpadding = 0,
        ypadding = 0,
        cellw = w/size_x - xpadding,
        cellh = h/size_y - ypadding


    var xScale = d3.scale.linear()
                         .domain([xcoord_edges[0], xcoord_edges[xcoord_edges.length-1]])
                         .range([padding, w-padding-wcb]);

    var yScale = d3.scale.linear()
                         .domain([ycoord_edges[0], ycoord_edges[ycoord_edges.length-1]])
                         .range([h-padding, padding]);                         

    

    if (xax){

var hxlabel=haxes.append("g")
  .attr("class", "my_flabel")
.append("text")
      .attr("class", "x label my_axis")
      
      .attr("text-anchor", "end")
      .attr("x", Math.round((w  )/2 ) )
      .attr("y", h-6 )
      .text(xlabel);

        var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .orient("bottom");

        haxes.append("g")
           .attr("class", "my_axis")
           .attr("transform","translate(0," + (h - padding) + ")")
           .call(xAxis);              
    }else{
        var hxlabel=false
        var xAxis=false
    }

    if (yax){

    var hylabel=haxes.append("g")
            .attr("class", "my_flabel")
      .append("text")
      .attr("class", "y label")
      .attr("transform", "rotate(-90)")
      .attr("y", 0)
      .attr("x", -Math.round((h-padding)/2))
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(ylabel);

        var yAxis = d3.svg.axis()
                      .scale(yScale)
                      .orient("left");

        haxes.append("g")
           .attr("class", "my_axis")
           .attr("transform", "translate(" + padding + ",0)")
           .call(yAxis);      
    }else{
        var hylabel=false
        var yAxis=false
    }

    return {svg:svg,div:div,haxes:haxes,xScale:xScale,yScale:yScale,wcb:wcb,padding:padding,hxlabel:hxlabel,hylabel:hylabel,htitle:htitle,i:i}
}



function pcolor(svg,tuples,m,M,num_cont,cmap){

    colours = make_cmap(cmap,m,M,num_cont);
 
    pclr = svg.append("g")
              .attr("class","my_pcolor")
              .selectAll("rect").data(tuples)
                         .enter()
                         .append("rect")
                         .attr("x", function(d){return d[1] })
                         .attr("y", function(d){return d[0] })
                         .attr("width", function(d){return d[3] })
                         .attr("height",function(d){return d[2] })

                         .attr("fill", function(d) { return colours(d[4]);})

                          .attr("stroke", function(d) { return colours(d[4]);});

    return pclr   
}

function colorbar(svg,m,M,boxes,wcb,padding,units,colours){

    if (wcb==0){
        return
    }

    var w=svg.attr("width"),   
        h=svg.attr("height"),
        bh = h/boxes,
//        cstep = (M-m)/boxes,
//        zs = d3.range(m,M,cstep),

        contl=find_conts(m,M,boxes)
        zs=contl.range,
        zs_str=cont2str(zs,1),
        from_fig = 5,
        from_bar =3,
        portion = 0.4,
        yticks = 6,
        axpos=w-padding,
        modulus = Math.round(boxes/yticks)
  
  
    var yScale=d3.scale.ordinal()
                  .domain(d3.range(zs.length)  )
                  .rangeRoundBands([h-padding,padding],0.01);

// 0.6 portion for text
    var cbar = svg.append("g")
                  .attr("class", "my_colorbar")

    var body=cbar.append("g")       
       .selectAll("rect")
       .data(zs)
       .enter()
       .append("rect")
       .attr("x", w-wcb-padding + from_fig)
       .attr("y", function(d,i){return yScale(i)})
       .attr("width",portion*wcb)
       .attr("height",yScale.rangeBand())
       .attr("fill", function(d){return colours(d)})

  //      var yAxis = d3.svg.axis()
 //                     .scale(yScale)
 //                     .orient("right");

 //       svg.append("g")
 //          .attr("class", "my_axis")
 //          .attr("transform", "translate(" + axpos + ",0)")
 //          .call(yAxis);      

       
    
    var labels = cbar.append("g")
       .attr("class", "my_colorbar")
       .selectAll("text")
       .data(zs)
       .enter()
       .append("text") 
       .text(function(d,i){
            if (i%modulus == 0){return cont2str([contl.om*d],1)[0]} return ''
       })
       .attr("x", w -(1-portion)*wcb -padding + from_fig +from_bar)
       .attr("y", function(d,i){return yScale(i)})

    if (units !='h'){
        cbar.append("g")
          .attr("class", "my_flabel")
              .append("text")
              .attr("class", "y label")
              .attr("transform", "rotate(-90)")
              .attr("y", w-padding+12)
              .attr("x", -Math.round((h-padding)/2))
              .attr("dy", ".71em")
              .style("text-anchor", "end")
              .text(units);
}

       
    return cbar
    
}



function plot_contour(svg,data,ycoord,xcoord,xScale,yScale,m,M, num_cont, conts, labels ){
 
     // d3 employs chain syntax. Example: d3.select("body").append("p").text("New paragraph!");

     // .select("body") â€” Give select() a CSS selector as input, and it will return a reference to the first element in the DOM that matches.
     // append(), in turn, hands down a reference to the new element it just created.
     //  .text puts the text inside the tags of the DOM element just handed to it.

     // Typically, a method returns a reference to the element that it just acted upon, but not always. 


    // d3.range creates an array [a1,a2,...] of values for zs much like Python arange 

    // scales are functions that map from an input domain to an output range.
    // The scale has additional methods that change its behavior. 
    // A scale object, such as that returned by d3.scale.linear, is both an object and a function. 

    // Like other classes in D3, scales follow the method chaining pattern where setter methods return the scale itself.


    console.log(xcoord[0])
    var w=svg.attr("width")
    var h=svg.attr("height")
    
    // initialize Conrec object with specific data
    var c = new Conrec(),
        zs,
        om
    
    if ( conts == false){
        contl=find_conts(m,M,num_cont)
       
        zs=cont2str(contl.range,1)
        om=contl.om

     //   cont_step = (M-m)/num_cont;
     //   zs = d3.range(m , M , cont_step);       
    }else{
     
        zs=conts;
        om=1.
    }
 
    // call contour method on existing Conrec object
    c.contour(data, 0, xcoord.length-1, 0, ycoord.length-1, xcoord, ycoord, zs.length, zs);
   
    // nesting the c.contourList() according to level and feed as data to d3

    nested = d3.nest().key(function(d) { return d.level}).entries(c.contourList())

    // created contour labels
    var lbpos = [],
        cont_i1 = 0,
        lbl;
    //    cont_i2 = 0;

    
    for (var i=0;i<nested.length;i++){
        for (var j=0;j<nested[i].values.length;j++){
            cont_i1 =  Math.floor((nested[i].values[j].length)*Math.random() )
    //        cont_i2 = Math.round(nested[i].values[j].length*3/4)

            lbl = om*parseFloat(nested[i].key )
            if (lbl == Math.round(lbl)){
                lbl=lbl.toFixed(0)

            }else{
                lbl=lbl.toFixed(1)
            }

            lbpos.push( [nested[i].values[j][cont_i1].x,nested[i].values[j][cont_i1].y,  lbl    ]  )

        }
    }
    
    var allcont = svg.append("g")  
    
    var contplot = allcont.append("g")
        .attr("class","my_contplot")
        .selectAll("g")
        .data( nested )
        .enter()
        .append("g")  // due to nesting, key is now the level
            .attr("class",function(d) { return "level_"+d.key})
    //        .style("fill",function(d) { console.log(d.key);return colours(d.key);})
   //         .style("fill",function(d) { return colours(d.key);}) 
            .style("fill","none")                       
            .style("stroke","black")
            .style("opacity",0.5)


    var conts = contplot.append("g")
                .selectAll("path")
                .data(function(d) { return d.values}) // note function in data method
                .enter()
          
                .append("svg:path")
                    .attr("d",d3.svg.line()  // this function is an iterator!
                        .x(function(d) { return xScale(d.x)})
                        .y(function(d) { return yScale(d.y)})
                        )


    if (labels){
        var clabels = allcont.append("g")
                .attr("class","my_clabel")
                .attr("clip-path","url(#p-area)")
                .selectAll("text")
                .data(lbpos) // note function in data method
                .enter()          
                .append("text")
               
                .text(function(d,i){
                  return d[2] })
                .attr("x", function(d) { return xScale( d[0]  )} )
                .attr("y", function(d) { return yScale(d[1])} )

    }

    return allcont
}

function ordermag(val){
    var exp=Math.round(Math.log(Math.abs(val))/Math.LN10-2),
        sign = val/Math.abs(val)

    return [Math.abs(val)/Math.pow(10, exp ), exp, sign]
}

function toOrdermag(val,ord){

    return Math.round(val/Math.pow(10,ord))*Math.pow(10,ord)
}

function cont2str(conts,decs){

    var lbl=0,
        strconts=[];

    for (var i=0;i<conts.length;i++){
        lbl = parseFloat(conts[i]);


        if ((Math.abs(lbl) > 100) || (Math.abs(lbl) < 0.01)){
          lbl=lbl.toExponential(1)
          

        }else if (lbl == Math.round(lbl)){
            lbl=lbl.toFixed(0)

        }else{
            lbl=lbl.toFixed(decs)
        }

    



        strconts.push(lbl)
    }
    return strconts

}


            
function find_conts(m,M,num_cont){            
  
  // finds convenient as round as possible contour values
      
        var om=ordermag(M-m),
            retom

        
        if (om[1] <= -2){
            var cont_step=(M-m)/num_cont

    //        console.log(m+'..'+M+'..'+cont_step)
      
            return {range:d3.range(m,M,cont_step) , om:1}

        }

        var dMM=om[0],
            omag=om[1],
            mm=toOrdermag(m,omag),
            MM=toOrdermag(M,omag),

     //       cont_step=toOrdermag(Math.round( (MM-mm)/num_cont ),omag)

           // This is a hack! to be fixed.

           cont_step=toOrdermag(Math.round( (MM-mm)/num_cont ),omag) 
           if (cont_step==0){
               cont_step=(M-m)/num_cont
           }

    //        cont_step=toOrdermag( (M-m)/num_cont ,om)

        console.log('omag '+omag + '  num_cont: ' + num_cont)
        console.log('baba ' + mm + '.. ' + dMM + ' .. '+MM + '.. ' + cont_step)
//        console.log('yaga ' + Math.floor(mm) + '.. ' + dMM + ' .. '+Math.ceil(MM) + '.. ' + cont_step)

        if (omag >2 || omag<-2){
            
            retom=Math.pow(10,-omag)
        }else{
            retom=1. 
        }

            
        return {range:d3.range(Math.floor(mm),Math.ceil(MM),cont_step) , om:retom}


}


cmaps = {standard:['#000099','#0000FF','#3399FF','#00CCFF','#00CC00','#66FF00','#FFFF00','#CC0000','#FF6633'], BWR:['blue','cyan','white','orange','red'],BW:['black','white']}

function make_cmap(map_name,m,M,num_cont){
    
    if (map_name == 'W'){
        return function (d){

            if (isNaN(d)){
                return 'black'
            }else{
                return 'white'
            }
        }
    }

    if (num_cont==0){
        var cmap = cmaps[map_name],
            step,
            zs_set;
      
        if (m<0 && M>0 && map_name=='BWR'){
            step = -2*m/(cmap.length-1)
            var step2=2*M/(cmap.length-1)
            zs_set = d3.range(m,0. ,step).concat(d3.range(0.,M  ,step2).concat([parseFloat(M)]));
  //          console.log(0.1*step2)
  //          console.log(d3.range(0.,M  ,step2).concat([parseFloat(M)]) )
        }else{
            step = (M - m)/ (cmap.length )
            zs_set = d3.range(m,M ,step);
        }

  //      zs_set=[parseFloat(10*m)].concat( zs_set)
  //      cmap = ['black'].concat(cmap)
        return d3.scale.linear().domain(zs_set).range(cmap);
    }
    else{


        var linmap=make_cmap(map_name,m,M,0);
    
        var zs_set=find_conts(m,M,num_cont).range,
            imzs=[];

        
        for (var i=0;i<zs_set.length;i++){

            imzs.push(linmap(zs_set[i]))
        }
        
   //     return d3.scale.quantize().domain([m,M]).range(imzs);



        var mapf=d3.scale.quantize().domain([m,M]).range(imzs);

        return function (d){

            if (isNaN(d)){
                return 'grey'
            }else{
                return mapf(d)
            }

        }




    }
};
 

function get_grid(data){
 
    var ycoord = data.grid.members[0].value 
    var xcoord = data.grid.members[1].value

    for (var i=0;i<xcoord.length;i++){
        xcoord[i] = xcoord[i] - 90.
    }

    var spacingX = xcoord[1] - xcoord[0];
    var spacingY = ycoord[1] - ycoord[0];
   
    var maxY = ycoord[ycoord.length-1]
    var minY = ycoord[0]

    var maxX = xcoord[xcoord.length-1]
    var minX = xcoord[0]

    console.log("spacingX: " + spacingX +"  spacingY: "+spacingY)

    console.log("Mx = "+maxX+"  mx = "+minX+"  My = "+maxY+"  my = "+minY + " => " +(maxX-minX)/spacingX+":"+(maxY-minY)/spacingY);

    console.log('Length of data is '+data.value.length)
    var new_data = prepare_data(data, xcoord, ycoord);

    var grid = make_grid(new_data, maxX, minX, maxY, minY, spacingX, spacingY)
 

    return {grid:grid, maxX:maxX,minX:minX, maxY:maxY, minY:minY   }
}

function make_grid(data, maxX, minX, maxY, minY, spacingX, spacingY){

 

    // The data is provided as an array of [lat, lon, value] arrays and it need to be mapped to a grid.
    // Determine the min and max latitudes and longitudes
 
   
    var grid_len_x = Math.round( (maxX-minX)/spacingX+1 )
    var grid_len_y = Math.round( (maxY-minY)/spacingY+1 )
    console.log("grid len X: " + grid_len_x)
     

    // Create a properly dimensioned array
    var grid=new Array( grid_len_x);

 
    for (var i=0;i<grid.length;i++)
        grid[i] = Array( grid_len_y );
            
    
    // Fill the grid with the values from the data array
    data.forEach(function(val){grid[Math.round((val[1]-minX)/spacingX)][Math.round( (val[0]-minY)/spacingY ) ]=val[2];});
            
    //Add a "cliff edge" to force contour lines to close along the border.          
    grid = make_cliff(grid);

   
   
    return grid
}

function make_cliff(grid){

    var cliff = -400;
    grid.push(d3.range(grid[0].length).map(function() { return cliff; }));
    grid.unshift(d3.range(grid[0].length).map(function() { return cliff; }));
    grid.forEach(function(nd) {
        nd.push(cliff);
        nd.unshift(cliff);
    });
   
    return grid
}

function data2xyvalue(data,xcoord,ycoord){
    // Returns a 2D grid as one array of 3-tuples of (y,x,value)
    //

    new_data = []
    for (var j=0;j<data.length;j++){
                        
        var row = data[j];
        for (var i=0;i<row.length;i++){
            var new_item = [ycoord[j],xcoord[i],row[i]]

            new_data.push(new_item)
        }
    }
return new_data;
}

function data2lines(data,xScale,yScale){

    var lineData = []
      
    for (var i=0;i<data.value.length;i++){
            
        lineData.push({x:xScale(data.coord0[i]),y:yScale(data.value[i])})           
    }
    
    return lineData
}


function data2rectangles(data,xScale,yScale){
    // Returns a 2D grid as one array of 5-tuples of (y,x,dy,dx,value) 
    // to be used to draw rectangles, with x,y the upper left corner and dy,dx the widths.


    var ycoord_edges=data.coord0_edges,
        xcoord_edges=data.coord1_edges;
     
    console.log(xScale)
    new_data = []
    for (var j=0;j<data.value.length;j++){
                        
        var row = data.value[j];
        for (var i=0;i<row.length;i++){
            var new_item = [yScale(ycoord_edges[j+1]),xScale(xcoord_edges[i]),Math.ceil(yScale(ycoord_edges[j])-yScale(ycoord_edges[j+1])),Math.ceil(xScale(xcoord_edges[j+1])-xScale(xcoord_edges[j]) ),row[i]]

            new_data.push(new_item)
        }
    }
return new_data;
}

        </script>

    </body>
</html>

