<!DOCTYPE html>
{% load static %}


<html lang="en">
<head>
        
<meta charset="utf-8" name="viewport" content="initial-scale=1.0, user-scalable=no"/>
  
  <!--      
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
 <script type="text/javascript" src="https://raw.github.com/jasondavies/conrec.js/master/conrec.js"></script>
	<script src="https://raw.github.com/d3/d3-plugins/master/geom/contour/contour.js"></script>
 -->

<script src="{% static "js/d3.v3.min.js" %}">  </script> 
<script src="{% static "js/conrec.js" %}">  </script>
<script src="{% static "js/contour.js" %}">  </script> 
<script src="{% static "js/jquery-2.1.1.min.js" %}">  </script>

<style type="text/css">
    h1 {
        font-family: sans-serif;
        color: lime;
    }
</style>

<style type="text/css">

body {
  position: relative;
}

svg,
canvas {
    position: relative;
}

.axis text {
    font: 10px sans-serif;
}

.axis path,
.axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
}



.my_axis path,
.my_axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.my_axis text {
    font-family: sans-serif;
    font-size: 11px;
}

.my_colorbar text {
    font-family: sans-serif;
    font-size: 11px;
}

.my_flabel text {
    font-family: sans-serif;
    font-size: 13px;
}

.my_clabel text {
    font-family: sans-serif;
    font-size: 12px;
}
      
.line {
  fill: none;
 
  stroke-width: 1.5px;
}     

.pos_top {
    position: relative;
    top: -400px;
}

</style>

<title>This is my page</title>
    
</head>
<body>
<h1>Data </h1>
   
 
    
<script type="text/javascript">


var cmaps = {standard:['#000090','#0000FF','#3399FF','#00CCFF','#00CC00','#66FF00','#FFFF00','#FF6633','#CC0000'], BWR:['blue','white','red'],BCYR:['#0000DD','cyan','#DDEEFF','yellow','red'],BW:['black','white'],W:['white'],GreenYellow:["#0a0", "#6c0", "#ee0", "#eb4", "#eb9", "#fff"],jet:['blue','cyan','#FFFFE0','orange','#cc0000'],jetlight:['rgb(215,48,39)','rgb(244,109,67)','rgb(253,174,97)','rgb(254,224,144)','rgb(255,255,191)','rgb(224,243,248)','rgb(171,217,233)','rgb(116,173,209)','rgb(69,117,180)'].reverse()
}

var w=500,
    h=300,
    wcb=50,
    padding=40;

                      
var div=d3.select("body")
          .append("div")
          .attr("id","yo")

//var svg=div.append("svg")
//              .attr("width",w)
//              .attr("height",h)
//              .attr("id","yo_svg")



var margin = {top: padding, right: padding+wcb, bottom: padding, left: padding};

var ctx;
var imageObj = new Image();

//var x = d3.scale.linear()
//    .domain([0, w])
//    .range([0, w]);


//var y = d3.scale.linear()
//    .domain([0, h])
//    .range([h, 0]);

//var xmin = x.domain()[0];
//var xmax = x.domain()[1];
//var ymin = y.domain()[0];
//var ymax = y.domain()[1];
    
//var xAxis_canvas = d3.svg.axis()
//    .scale(x)
//    .orient("bottom");
    
//var yAxis_canvas = d3.svg.axis()
//    .scale(y)
//    .orient("left");

var divPlot=div
          .append("div")
          .attr("id","plots")
          .style("height",h+2*padding+"px")

var canvas = divPlot.append("canvas")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .style("left", margin.left + "px")
        .style("top", margin.top + "px")
        .style("width", w + "px")
        .style("height", h + "px")
        .style("position", "relative")

var svg = divPlot.append("svg")
//.attr("class","pos_top")
    .attr("width", w + margin.left + margin.right)
    .attr("height", h + margin.top + margin.bottom)
    .style("top", -h-3+"px")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
//        .style("position", "relative")
        

// We make an invisible rectangle to intercept mouse events for zooming.
//svg.append("rect")
//    .attr("width", width)
//    .attr("height", height)
//    .style("fill", "000")
//    .style("opacity", 1e-6)
//    .call(zoom);

//svg.append("g")
//        .attr("class", "x axis")
//        .attr("transform", "translate(0," + h + ")")
//        .call(xAxis_canvas)
//        .call(removeZero);

//svg.append("g")
//        .attr("class", "y axis")
//        .call(yAxis_canvas)
//        .call(removeZero);







menuStart(div)

function clearPlot(div){
	div.selectAll(".tempbut").remove(); 
    div.selectAll(".cyclebut").remove();
    div.selectAll(".my_pcolor").remove();
    // some of these divs were svg
    div.selectAll(".my_colorbar").remove();
    div.selectAll(".my_flabel").remove();
    div.selectAll(".my_contplot").remove();
    div.selectAll(".my_clabel").remove();

}

function refresh2D(div,url){

    clearPlot(div)

    d3.json(url,function(data){dimdesp(div,data)})

    return div
}

function menuStart(div){

    var url="/sgdata/projects/my_project/"
    d3.json(url,function(data){

    var h=makeChecks(div,data.expers,"change",checkChanged,"checkbox","expchecks","checkel");


    var plotArea=div.select("svg").append("g")
        .attr("class","my_plot")
        



    h.append("button")
      .attr("id","checkbut")
      .text("submit")
      .on("click",function(){
        // take all those checkboxes with checked is true
        // and construct array of corresponding values
        var w=h.selectAll(".checkel")[0],
            exps=[],
            fldstr='',
            ddbox,
            ops

        // build the URL segment
        for (var i=0;i<w.length;i++){
            if (w[i].checked){
                ddbox=h.select(".fsl"+i).select(".varsel")
//                flds.push(ddbox[0][0].value)
                exps.push('P__'+w[i].value+'__'+ddbox[0][0].value)
            }
        }

        w=h.selectAll(".radioel")[0],
            minusexp=false

        // build the URL segment
        for (var i=0;i<w.length;i++){
            if (w[i].checked){
                ddbox=h.select(".fslrad"+i).select(".varsel")
//                flds.push(ddbox[0][0].value)

                minusexp='P__'+w[i].value+'__'+ddbox[0][0].value
            }
        }

        ops=h.select(".selop")[0][0].value
        
        var op2=h.select(".selop2")[0][0].value

        var op3=h.select(".selop3")[0][0].value


        ops=[op3,op2,ops].join("*")
     
        fldstr = exps.join("++")

        if (minusexp){
            fldstr=fldstr+'-'+minusexp
        }

   //     console.log(prep_url(fldstr,ops))
        refresh2D(div,prep_url(fldstr,ops))
  //      fieldSel(div,exps.join("+"))
      })

      addChecks(div,"change",radioChanged,"checkbox","expradios","radioel")

      var url="/sgdata/projects/my_project/list_ops/"
      d3.json(url,function(data){
          makeDropdown(h,data,opChanged).attr("class","selop")
      })

      d3.json(url,function(data){
          makeDropdown(h,data,opChanged).attr("class","selop2")
      })


      d3.json(url,function(data){
          makeDropdown(h,data,opChanged).attr("class","selop3")
      })

      makeDropdown(h,['pcolor','image'],pcolChanged).attr("class","selpcolor")

    })
}

function fieldInfo(div,value){
	console.log("Info for " + value)
}

function URLDropdown(div,url,func){

// create dropdown list with field names
    d3.json(url,function(data){
        makeDropdown(div,data.vars,func).attr("id","varsel").attr("name","vars")
    });
}


function makeDropdown(div,data,func){

// create dropdown list with data names
   
    var dn=div.append("select")
 //       .attr("id","varsel")
 //       .attr("name","vars")
        .on("change", function(){func(div, this.value)
    })

    dn.selectAll("option")
    .data(data)
    .enter()
    .append("option")
    .text(function(d){return d})
    .attr("value",function(d){return d})
    
    return dn
}




function fieldSelEach(div,exp){
    // expects one exper

    var url='/sgdata/projects/my_project/'+exp + '/'
console.log(url),
//URLChecks(div,'/sgdata/projects/my_project/',refresh2D)
 
        h=div.append("div")
             .attr("name","sel_"+exp)

   d3.json(url,function(data){
        makeDropdown(h,data.vars,fieldInfo).attr("class","varsel").attr("name","vars")

 //   URLDropdown(div,url,refresh2D)

    })

    return h
}

function fieldSel(div,exp){
    // expects one exper

    var url='/sgdata/projects/my_project/'+exp + '/'
console.log(url),
//URLChecks(div,'/sgdata/projects/my_project/',refresh2D)
 
    h=div.append("div")
         .attr("name","sel_"+exp)

    d3.json(url,function(data){
        makeDropdown(h,data.vars,fieldInfo).attr("class","varsel").attr("name","vars")

 //   URLDropdown(div,url,refresh2D)

    })

    return h
}


function radioChanged(div,value,i,checked){
    console.log(value + ' ' + checked)

    div.selectAll(".radio").remove()

    if (checked){
 
        var thisDiv=div.select(".checkDiv"+i)
    //    var h=div.select(".checkDiv"+i)
        fieldSel(thisDiv, value)
               .attr("class","radio  fslrad"+i)

    div.selectAll(".radioel")
       .property("checked",false)

    thisDiv.select(".radioel")
           .property("checked",true)
                   
    }
}


function checkChanged(div,value,i,checked){
	console.log(value + ' ' + checked)
	if (checked){
	//    var h=div.select(".checkDiv"+i)
	    fieldSel(div.select(".checkDiv"+i), value)
	            .attr("class","fsl"+i)
        console.log("checking this one")               
    }else{
	    div.select(".fsl"+i).remove()
    }
}


function opChanged(div,value){
    console.log('Op dropdown has changed')
}

function pcolChanged(div,value){
    console.log('pcol dropdown has changed')
}
function makeChecks(div,data,action,func,type,name,cls){

// create check boxes list with data names

    var dn=div.append("div")
              .attr("class","tempdiv mainCheck")
        
    dn.selectAll("input")
    .data(data)
    .enter()
    .append("div")
    .attr("class",function(d,i){return "checkDiv"+i} )
    .text(function(d){return d})
    .append("input")
    .attr("class",cls)
    .attr("type",type)
    .attr("name",name)
    .attr("id",function(d,i){return "myCheck"+i} )
    .attr("value",function(d){return d})
//    .text(function(d){return d})
//    .attr("value",function(d){return d})
    .on(action, function(d,i){func(div,d,i, this.checked)})

    return dn
}


function addChecks(div,action,func,type,name,cls){

// create check boxes list with data names

    var dn=div.select(".mainCheck")
    .selectAll("div")

    .append("input")
    .attr("class",cls)
    .attr("name",name)
    .attr("type",type)
//    .attr("id",function(d,i){return "myRadio"+i} )
    .attr("value",function(d){return d})
//    .text(function(d){return d})
//    .attr("value",function(d){return d})
    .on(action, function(d,i){func(div,d,i, this.checked)})

    return dn
}



function handle_more_data(axob,data){

    data = handle_nan(data,NaN);
    data.lname ='' // block out title as this is a secondary plot

    return plot_contour(axob.svg,d3.transpose(data.value),data.coord0,data.coord1,axob.xScale,axob.yScale,data.m,data.M,12, false, true);
}

function handle_nan2D(value,nanval){

    var row
    for (var i=0;i<value.length;i++){
        row=value[i]
        for (var j=0;j<row.length;j++){
            if (row[j] < -8e20){
   
   // this needs to be some other value for d3.max and d3.min to work.
                row[j] = nanval
            }
        }
    }
    return value
}

function handle_nan(data,nanval){
    console.log("handling nan for dim "+data.ndim)
    
    if (data.ndim==1){
      
        for (var i=0;i<data.value.length;i++){
            if (data.value[i]<-8e20){
                data.value[i]=nanval
            }
        }


    }else if (data.ndim==2){
        data.value=handle_nan2D(data.value,nanval)        
    }else{
        for (var i=0;i<data.slices.length;i++){
            data.slices[i].value=handle_nan2D(data.slices[i].value,nanval);
        }    
    }
    return data
}


function dimdesp(div,data){
//    console.log(data)
    

    if (data.ndim>3){
        console.log("dim > 4 not implemented yet")
        return
    }

    if (data.ndim>1){

        if (data.ndim==2){
           
            if(data.coord0.length<10){
                handle_series(div,data)
            }else{
                rha(div,data)
            }

        }else{
            rha(div,data)
        }
    }else {
        console.log('1D')
        handle1Ds(div,data)
    }
}


function init_nseries(value,coord){
    var nseries=[]

    nseries.push({key:0,values:value2lines(value,coord)})

    return nseries
}


function add_nseries(nseries, value,coord){

    var new_key=nseries[nseries.length-1].key+1

    nseries.push({key:new_key,values:value2lines(value,coord)})

    return nseries
}


// value2lines(value,coord)

// 1D functions ----------------

function handle_series(div,data){
    // in this case multiple time series have been received

    // coord0 is the experiment coord
    // coord1 is the spatial coord
    data=handle_nan(data,0)

    var coord=data.coord1
    var nseries=init_nseries(data.value[0],coord)

    var ylabel=data.units,
        xlabel=data.coord1_lname,    
        title=data.lname;

    if (data.value.length>1){
        for (i=1;i<data.value.length;i++){
            nseries=add_nseries(nseries,data.value[i],coord)
        }
    }

    var hndls=doPlots(div,nseries,title,xlabel,ylabel)
  
    return hndls
}

function handle1Ds(div,data){

    data=handle_nan(data,0)
    var coord=data.coord0
    var nseries=init_nseries(data.value,coord)
 
    var ylabel=data.units,
        xlabel=data.coord0_lname,    
        title=data.lname;

    var hndls=doPlots(div,nseries,title,xlabel,ylabel)
  
    return hndls    


}





function doPlots(div,nseries,title,xlabel,ylabel){
 // determine scales and plot series

    var MARGINS = {
        top: 30,
        right: 20,
        bottom: 35,
        left: 50
    }

    var svg=div.selectAll("svg")
    
    svg.select('.my_plot').selectAll("rect").remove()

    var canvas=d3.select("canvas"),
        ctx = canvas.node().getContext("2d")

    ctx.clearRect( 0 , 0 , canvas.attr("width") , canvas.attr("height") );

    var Mm=make_axes(svg,nseries)

    // draw the axes
    var axob=prep_axes1Ds(div, Mm.xScale, Mm.yScale,true,true,-1,MARGINS)

    var lbls=dolabels(div,title,xlabel,ylabel,-1,MARGINS)

    var plts=plots(svg, nseries, Mm.xScale, Mm.yScale)

    return plts
}  


function plots(svg, nseries, xScale, yScale){
    // nseries is nested arrays of lineData type arrays
 // e.g. [  {key: 1, values: [{x:0, y:10} , {x:1, y:12}, … ] , key: 2, values: [{x:0,y:15} , {x:1,y:14}, … ]  ]

    var linecols=['steelblue','red','green','black','yellow','blue']

    var lineFunc = d3.svg.line()
                        .x(function(d) {
                            return xScale(d.x);
                        })
                        .y(function(d) {
                            return yScale(d.y);
                        })
                        .interpolate('linear');
   
    

    var curves = svg.select(".my_plot")
        .selectAll("g")
        .data(nseries)  // the nested lineData type arrays

    curves.enter()  // enter only the series, not their individual points
        .append("g")  // due to nesting, key is now the series id
            .attr("class",function(d) { return "series series_"+d.key    })                 
            .style("stroke",function(d) { return linecols[d.key]    })
//            .style("opacity",0.5)
            .append("path")
                    .attr("class","line")
                    .attr('d', function(d){return lineFunc(d.values) } ); 


    curves.transition()
          .duration(1000)
                   
          .style("stroke",function(d) {return linecols[d.key]    })
//            .style("opacity",0.5)
          .select("path")
          .attr('d', function(d){return lineFunc(d.values) } ); 

    curves.exit()
          .transition()
          .duration(500)
          .remove();

    return curves
}



function value2lines(value,coord){

    var lineData = []
      
    for (var i=0;i<value.length;i++){
            
        lineData.push({x:coord[i],y:value[i]})           
    }   
    return lineData
}


function data2lines(data){

    return value2lines(data.value, data.coord0)
}



function dolabels(div,title,xlabel,ylabel,i,MARGINS){

    var svg=div.selectAll("svg")

    var w=svg.attr("width"),
        h=svg.attr("height")

    haxes=svg.select(".my_flabel")

    if (i >-1){
        title =  ' ('+String.fromCharCode(97+i) +') '+title
    }

    var htitle=haxes.append("g")
        .attr("class", "my_flabel")
        .append("text")
//      .attr("class", "x label")
        .attr("class", "my_axis my_plot_title")
      
        .attr("text-anchor", "start")
        .attr("x", MARGINS.left  )
        .attr("y", MARGINS.top -15)
        .text(title);

    var hxlabel=haxes.append("g")
                .attr("class", "my_flabel")
                .append("text")
                .attr("class", "x label my_axis")
          
                .attr("text-anchor", "end")
                .attr("x", MARGINS.left+ Math.round((w-MARGINS.left-MARGINS.right )/2))
                .attr("y", h-MARGINS.bottom+31 )
                .text(xlabel);

    var hylabel=haxes.append("g")
                .attr("class", "my_flabel")
                .append("text")
                .attr("class", "y label")
                .attr("transform", "rotate(-90)")
                .attr("y", 56)
                .attr("x", -Math.round(h/6))
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text(ylabel);

    return {htitle:htitle,hxlabel:hxlabel,hylabel:hylabel}
}

function prep_axes1Ds(div, xScale,yScale,xax,yax,i,MARGINS){

    console.log(padding)

    var svg=div.selectAll("svg")

    var w=svg.attr("width"),
        h=svg.attr("height"),

        units="",
        xlabel="",    
        ylabel="",
        title="";
 
    var haxes=svg.append("g")
                .attr("class","my_flabel my_plot_axes")
            
    if (xax){ 

        var xAxis = d3.svg.axis()
                 .scale(xScale)
                 .tickSize(5)
                 .tickSubdivide(true);

    haxes.append('g')
      .attr('class', "my_x_axis my_axis")

      .attr('transform', 'translate(0,' + (h - MARGINS.bottom) + ')')
      .call(xAxis);
    } 

    if (yax){

        var yAxis = d3.svg.axis()
          .scale(yScale)
          .tickSize(5)
          .orient('left')
          .tickSubdivide(true);

        haxes.append('g')
         .attr('class', "my_y_axis my_axis")
         .attr('transform', 'translate(' + (MARGINS.left) + ',0)')
         .call(yAxis);
    }  

//    return {svg:svg,div:div,haxes:haxes,xScale:xScale,yScale:yScale,hxlabel:hxlabel,hylabel:hylabel,htitle:htitle,i:i}

    return {svg:svg,div:div,haxes:haxes,xScale:xScale,yScale:yScale,i:i}
}






function findM4one(lineData){

    var Mx=d3.max(lineData, function(d){return d.x;}),
        mx=d3.min(lineData, function(d){return d.x;}),
        My=d3.max(lineData, function(d){return d.y;}),
        my=d3.min(lineData, function(d){return d.y;})

    return {Mx:Mx,mx:mx,My:My,my:my}    
}

function findM(nseries){

    var Mxs=[],
        mxs=[],
        Mys=[],
        mys=[]

    var Mm 

 //   var lineDatas=map(nseries).values()

    for (i=0;i<nseries.length;i++){
        Mm=findM4one(nseries[i].values)
        Mxs.push(Mm.Mx)
        mxs.push(Mm.mx)
        Mys.push(Mm.My)
        mys.push(Mm.my)
    }

    return {Mx:d3.max(Mxs),mx:d3.min(mxs),My:d3.max(Mys),my:d3.min(mys)}
}




function make_axes(svg,nseries){

    var svg=div.selectAll("svg")

    var w=svg.attr("width"),
        h=svg.attr("height")

    var Mm=findM(nseries)


    var MARGINS = {
        top: 30,
        right: 20,
        bottom: 30,
        left: 50
    },
    xScale = d3.scale.linear().range([MARGINS.left, w - MARGINS.right]).domain([Mm.mx,Mm.Mx]),
    yScale = d3.scale.linear().range([h - MARGINS.top, MARGINS.bottom]).domain([Mm.my, Mm.My]);

    return {xScale:xScale,yScale:yScale}
}




// 2D functions ----------------


function prep_axes(div, data,padding,wcb,xax,yax,i){
    // add labels and axes
    // create axes object axob containing information about labels and axes, including handles to entire label set and subsets

    var svg=div.selectAll("svg")

    var ycoord_edges=data.coord0_edges,
        xcoord_edges=data.coord1_edges,
        m=data.m,
        M=data.M,
        units=data.units,
        xlabel=data.coord1_lname,    
        ylabel=data.coord0_lname,
        title=data.lname;

    var w=svg.attr("width"),
        h=svg.attr("height");
        
    if (i >-1){
        title =  ' ('+String.fromCharCode(97+i) +') '+title

    }

    var haxes=svg.append("g")
             .attr("class","my_flabel")

    var htitle=haxes.append("g")
               .attr("class", "my_flabel")
               .append("text")
//      .attr("class", "x label")
               .attr("class", "my_axis")
               .attr("text-anchor", "start")
               .attr("x", padding  )
               .attr("y", 25 )
               .text(title);

    // contains array of (y,x,dy,dx,value)

 //    colours = make_cmap('standard',m,M,num_cont);

    var size_y = ycoord_edges.length-1,
        size_x = xcoord_edges.length-1
    
    
    var xpadding = 0,
        ypadding = 0,
        cellw = w/size_x - xpadding,
        cellh = h/size_y - ypadding


    var xScale = d3.scale.linear()
                         .domain([xcoord_edges[0], xcoord_edges[xcoord_edges.length-1]])
                         .range([padding, w-padding-wcb]);

    var yScale = d3.scale.linear()
                         .domain([ycoord_edges[0], ycoord_edges[ycoord_edges.length-1]])
                         .range([h-padding, padding]);  

    if (xax){

var hxlabel=haxes.append("g")
  .attr("class", "my_flabel")
.append("text")
      .attr("class", "x label my_axis")
      
      .attr("text-anchor", "end")
      .attr("x", Math.round((w  )/2 ) )
      .attr("y", h-6 )
      .text(xlabel);

        var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .orient("bottom");

        haxes.append("g")
           .attr("class", "my_axis")
           .attr("transform","translate(0," + (h - padding) + ")")
           .call(xAxis);              
    }else{
        var hxlabel=false
        var xAxis=false
    }

    if (yax){

    var hylabel=haxes.append("g")
            .attr("class", "my_flabel")
      .append("text")
      .attr("class", "y label")
      .attr("transform", "rotate(-90)")
      .attr("y", 0)
      .attr("x", -Math.round((h-padding)/2))
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(ylabel);

        var yAxis = d3.svg.axis()
                      .scale(yScale)
                      .orient("left");

        haxes.append("g")
           .attr("class", "my_axis")
           .attr("transform", "translate(" + padding + ",0)")
           .call(yAxis);      
    }else{
        var hylabel=false
        var yAxis=false
    }

    return {svg:svg,div:div,haxes:haxes,xScale:xScale,yScale:yScale,wcb:wcb,padding:padding,hxlabel:hxlabel,hylabel:hylabel,htitle:htitle,i:i}
}

function makeUpdateCmap(data,num_cont){

   function func(div,map){
        
       var svg=div.select("svg")
    
       var colours=make_cmap(map,data.m,data.M,num_cont);


       if (div.select(".selpcolor")[0][0].value=='image'){
           div.select('.my_plot').selectAll("rect").remove()
           doImage(svg,data,colours) 
       }else{
           updateColors(svg,colours)
       }
  
       updateCBar(svg,colours)   
   } 

    return func
}








function updateColors(svg,colours){
    var pclr=svg.select(".my_plot")
                .selectAll("rect")
                .transition()
                .duration(200)
                .attr("stroke", function(d) { return colours(d[4]);})
                .attr("fill", function(d) { return colours(d[4]);});                
}

function pcolor(svg,tuples,colours){

    var pclr = svg.select(".my_plot")
              
              .selectAll("rect")
              .data(tuples)

        pclr.enter()
            .append("rect")
            .attr("x", function(d){return d[1] })
            .attr("y", function(d){return d[0] })
            .attr("width", function(d){return d[3] })
            .attr("height",function(d){return d[2] })

            .attr("fill", function(d) { return colours(d[4]);})

            .attr("stroke", function(d) { return colours(d[4]);})
//            .on("click",function(d){console.log(d)})

        pclr.transition()
            .duration(200)
            .attr("x", function(d){return d[1] })
            .attr("y", function(d){return d[0] })
            .attr("width", function(d){return d[3] })
            .attr("height",function(d){return d[2] })
            .attr("fill", function(d) { return colours(d[4]);})
            .attr("stroke", function(d) { return colours(d[4]);});

        pclr.exit()
            .transition()
            .duration(500)
            .remove();

    return pclr   
}



function rha(div,data){
     
    // handle 2D and 3D fields

    console.log("rha")

    data = handle_nan(data,NaN)
    var svg=div.selectAll("svg")
    
    var wcb=50,
    padding=40;

    // calculate scales
  
    div.selectAll(".series").remove();

    if (data.ndim==3){
        // this puts the axes on the figure AND returns axob
        axob=prep_axes(div, data.slices[0],padding,wcb,true,true,-1)

        addcycler(axob,data,"button",display2D)
    }else if (data.ndim==2){
        axob=prep_axes(div, data,padding,wcb,true,true,-1)
       
        elms = display2D(axob,data)
    }
 //   console.log('over here')


    var checks=axob.div.select(".mainCheck")
                   .selectAll(".checkel")
    

    var exp=false
    for (var i=0;i<checks[0].length;i++){
        if (checks[0][i].checked){
            exp=checks[0][i].value
            break
        }
    }

d3.json(prep_url('P__'+exp+'__G_kmt',ops="nop"),function(error,data){
    if (error) return console.warn(error);
    addtoggle(axob,data,"button",my_kmt,"geog off","geography","click")})

    but=axob.div.append("button")
        but.attr("id","extra_field")
           .attr("class","tempbut")
            .text("extra field")
            .on("click",function(d){
   d3.json(prep_url('P__'+exp+'__O_psi',ops="nop"),function(error,data){
    if (error) return console.warn(error);
    addtoggle(axob,data,"button",handle_more_data,"psi off","psi","click")})
             })



}







function display2D(axob,data){
    var elms=[],
        but

    var num_col=30

    makeDropdown(div,d3.keys(cmaps),makeUpdateCmap(data,num_col))
    .attr("class","tempbut")
    .attr("name","colormap")
    .attr("id","cmap")

    var map=div.select("#cmap")[0][0].value

    var colours=make_cmap(map,data.m,data.M,num_col);

       if (div.select(".selpcolor")[0][0].value=='image')

    axob.div.selectAll(".series").remove();
//
    var plotType=div.select(".selpcolor")[0][0].value
   
    if (plotType=='image'){
       
        axob.div.select('.my_plot').selectAll("rect").remove()
        elms = elms.concat(doImage(svg,data,colours))
    }else{
        elms = elms.concat(doPcolor(axob,data,colours))        
    }
    axob.svg.selectAll(".my_colorbar").remove()
    elms = elms.concat(colorbar(axob.svg,data.m,data.M,30, axob.wcb,axob.padding,data.units,colours) );

// element w=handle_more_data(axob,data) is removed again with w.remove()

    elms = elms.concat(addtoggle(axob,data,"button",handle_more_data,"conts off","conts","click"))



    

    return elms
}



function toggle(w,axob,data,but,func,onms,offms){

    if (w==false){
        but.text(onms)
        return func(axob,data);
    }else{
        w.remove()
        but.text(offms)
        return false
    }    
};

function addtoggle(axob,data,tag,func,onms,offms,event){
    // adds interactive element to toggle content of div

    var w,
        but  // interactive element handle
    // data available in namespace
 //   var offms="contours",
 //       onms="remove conts";
    but=axob.div.append(tag)
            .attr("class","tempbut")
    but.attr("id",onms+offms)
        .text(offms)
        .on(event,function(d){
            // need to wrap toggle var w inside here:
            w=toggle(false,axob,data,but,func,onms,offms)
            
            but.on("click",function(d){
                w=toggle(w,axob,data,but,func,onms,offms)   
            });
         })

    return [but]
}



function remhandles(handles){
    console.log(handles)
    for (var i=0;i<handles.length;i++){
        try{
            handles[i].remove()
        }catch(err){

        }
    }
}

function cycler(w,wmax,axob,data,but,func){

    w=(w+1)%wmax

    console.log(data.slices[w])

    but.text(data.scoord[w])
    return [w,func(axob,data.slices[w])]

};


function addcycler(axob,data,tag,func){
   // adds an element such as button to cycle through 3D field 
   // tag is usually "button"
    var w,
        clr,
        wmax=data.slices.length,
        but

    but=axob.div.append(tag)
    but.attr("id","cycler"+data.name)
        .attr("class","cyclebut")
        .text("cycle from "+ data.scoord[0])
 

            // need to wrap cycler var w inside here:
            clr=cycler(-1,wmax,axob,data,but,func)
            w=clr[0]

            but.on("click",function(d){
 
                remhandles(clr[1])
                // unfortunate hack:
                axob.svg.selectAll(".my_contplot").remove()
                axob.svg.selectAll(".my_clabel").remove()
                axob.div.selectAll(".tempbut").remove()

                clr=cycler(w,wmax,axob,data,but,func);
                w=clr[0]  
               
            });
}


function my_kmt(axob,data){

   // data = handle_nan(data);
    data.lname =''


    var w=axob.svg.attr("width")
    var h=axob.svg.attr("height")
 
    return plot_contour(axob.svg,d3.transpose(data.value),data.coord0,data.coord1,axob.xScale,axob.yScale,data.m,data.M,12, [0.5], false);
  
};


function doImage(svg,data,colours){

//    var colours=make_cmap('GreenYellow',data.m,data.M,24),

    xmax = data.value[0].length,
    ymax = data.value.length;

    var xsc = d3.scale.linear()
        .domain([data.coord1[0], data.coord1[data.coord1.length-1]])
        .range([0, xmax]);


    var ysc = d3.scale.linear()
        .domain([data.coord0[0], data.coord0[data.coord0.length-1]])
        .range([ymax,0]);

    d3.select("canvas")
        .attr("width", xmax)
        .attr("height", ymax)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(drawImage);

//  console.log(data.coord0)
  // Compute the pixel colors; scaled by CSS.
    function drawImage(canvas) {
        var i,j
        ctx = canvas.node().getContext("2d");
        var img = ctx.createImageData(xmax, ymax);
        for (var y = 0, p = -1; y < ymax; ++y) {
            for (var x = 0; x < xmax; ++x) {
                i=Math.min(Math.round(xsc(data.coord1[x])), xmax-1 )
                j=Math.min(Math.round(ysc(data.coord0[y])),ymax-1 )

 //               console.log(i)

 //               console.log(j)

                var c = d3.rgb(colours(data.value[j][i]));
                img.data[++p] = c.r;
                img.data[++p] = c.g;
                img.data[++p] = c.b;
                img.data[++p] = 255;
            }
//        console.log(j + ', ' +y)
        }
        ctx.putImageData(img, 0, 0);
        imageObj.src = canvas.node().toDataURL();
    }

    return [ctx,]
}

function doPcolor(axob,data,colours){
 
    // cast data as tuples to be used in pcolor
    tuples = data2rectangles(data,axob.xScale,axob.yScale)

    var colours=make_cmap('standard',data.m,data.M,24);
    var pclr=pcolor(axob.svg,tuples,colours)



    return [pclr,]             
};

function prep_url(varname,ops){
    var opstr=''

    if (ops !="nop"){
        opstr='?ops='+ops
    }

    return '/sgdata/my_project/' + varname+'/ops/'+opstr
}


//svg, data.coord0_edges,data.coord1_edges,data.m,data.M,padding,wcb,true,true,data.units,data.coord1_lname,data.coord0_lname,data.lname,-1


function updateCBar(svg,colours){
    var pclr=svg.select(".my_colorbar")
                .selectAll("rect")
                .transition()
                .duration(200)
                .attr("fill", function(d){return colours(d)})
                .attr("stroke", function(d) { return colours(d);})          
}

function colorbar(svg,m,M,boxes,wcb,padding,units,colours){

    if (wcb==0){
        return
    }

    var w=svg.attr("width"),   
        h=svg.attr("height"),
        bh = h/boxes,
//        cstep = (M-m)/boxes,
//        zs = d3.range(m,M,cstep),

        contl=find_conts(m,M,boxes)
        zs=contl.range,
        zs_str=cont2str(zs,1),
        from_fig = 5,
        from_bar =3,
        portion = 0.4,
        yticks = 6,
        axpos=w-padding,
        modulus = Math.round(boxes/yticks)
  
  
    var yScale=d3.scale.ordinal()
                  .domain(d3.range(zs.length)  )
                  .rangeRoundBands([h-padding,padding],0.01);

// 0.6 portion for text
    var cbar = svg.append("g")
                  .attr("class", "my_colorbar")

    var body=cbar.append("g")       
       .selectAll("rect")
       .data(zs)
       .enter()
       .append("rect")
       .attr("x", w-wcb-padding + from_fig)
       .attr("y", function(d,i){return yScale(i)})
       .attr("width",portion*wcb)
       .attr("height",yScale.rangeBand())
       .attr("fill", function(d){return colours(d)})
       .attr("stroke", function(d) { return colours(d);})
  //      var yAxis = d3.svg.axis()
 //                     .scale(yScale)
 //                     .orient("right");

 //       svg.append("g")
 //          .attr("class", "my_axis")
 //          .attr("transform", "translate(" + axpos + ",0)")
 //          .call(yAxis);      

       
    
    var labels = cbar.append("g")
       .attr("class", "my_colorbar")
       .selectAll("text")
       .data(zs)
       .enter()
       .append("text") 
       .text(function(d,i){
            if (i%modulus == 0){return cont2str([contl.om*d],1)[0]} return ''
       })
       .attr("x", w -(1-portion)*wcb -padding + from_fig +from_bar)
       .attr("y", function(d,i){return yScale(i)})

    if (units !='h'){
        cbar.append("g")
          .attr("class", "my_flabel")
              .append("text")
              .attr("class", "y label")
              .attr("transform", "rotate(-90)")
              .attr("y", w-padding+12)
              .attr("x", -Math.round((h-padding)/2))
              .attr("dy", ".71em")
              .style("text-anchor", "end")
              .text(units);
}

       
    return cbar
    
}



function plot_contour(svg,data,ycoord,xcoord,xScale,yScale,m,M, num_cont, conts, labels ){
 
     // d3 employs chain syntax. Example: d3.select("body").append("p").text("New paragraph!");

     // .select("body") — Give select() a CSS selector as input, and it will return a reference to the first element in the DOM that matches.
     // append(), in turn, hands down a reference to the new element it just created.
     //  .text puts the text inside the tags of the DOM element just handed to it.

     // Typically, a method returns a reference to the element that it just acted upon, but not always. 


    // d3.range creates an array [a1,a2,...] of values for zs much like Python arange 

    // scales are functions that map from an input domain to an output range.
    // The scale has additional methods that change its behavior. 
    // A scale object, such as that returned by d3.scale.linear, is both an object and a function. 

    // Like other classes in D3, scales follow the method chaining pattern where setter methods return the scale itself.


    console.log(xcoord[0])
    var w=svg.attr("width")
    var h=svg.attr("height")
    
    // initialize Conrec object with specific data
    var c = new Conrec(),
        zs,
        om
    
    if ( conts == false){
        contl=find_conts(m,M,num_cont)
       
        zs=cont2str(contl.range,1)
        om=contl.om

     //   cont_step = (M-m)/num_cont;
     //   zs = d3.range(m , M , cont_step);       
    }else{
     
        zs=conts;
        om=1.
    }
 
    // call contour method on existing Conrec object
    c.contour(data, 0, xcoord.length-1, 0, ycoord.length-1, xcoord, ycoord, zs.length, zs);
   
    // nesting the c.contourList() according to level and feed as data to d3

    nested = d3.nest().key(function(d) { return d.level}).entries(c.contourList())

    // created contour labels
    var lbpos = [],
        cont_i1 = 0,
        lbl;
    //    cont_i2 = 0;

    
    for (var i=0;i<nested.length;i++){
        for (var j=0;j<nested[i].values.length;j++){
            cont_i1 =  Math.floor((nested[i].values[j].length)*Math.random() )
    //        cont_i2 = Math.round(nested[i].values[j].length*3/4)

            lbl = om*parseFloat(nested[i].key )
            if (lbl == Math.round(lbl)){
                lbl=lbl.toFixed(0)

            }else{
                lbl=lbl.toFixed(1)
            }

            lbpos.push( [nested[i].values[j][cont_i1].x,nested[i].values[j][cont_i1].y,  lbl    ]  )

        }
    }
    
    var allcont = svg.append("g")  
    
    var contplot = allcont.append("g")
        .attr("class","my_contplot")
        .selectAll("g")
        .data( nested )
        .enter()
        .append("g")  // due to nesting, key is now the level
            .attr("class",function(d) { return "level_"+d.key})
    //        .style("fill",function(d) { console.log(d.key);return colours(d.key);})
   //         .style("fill",function(d) { return colours(d.key);}) 
            .style("fill","none")                       
            .style("stroke","black")
            .style("opacity",0.5)


    var conts = contplot.append("g")
                .selectAll("path")
                .data(function(d) { return d.values}) // note function in data method
                .enter()
          
                .append("svg:path")
                    .attr("d",d3.svg.line()  // this function is an iterator!
                        .x(function(d) { return xScale(d.x)})
                        .y(function(d) { return yScale(d.y)})
                        )


    if (labels){
        var clabels = allcont.append("g")
                .attr("class","my_clabel")
                .attr("clip-path","url(#p-area)")
                .selectAll("text")
                .data(lbpos) // note function in data method
                .enter()          
                .append("text")
               
                .text(function(d,i){
                  return d[2] })
                .attr("x", function(d) { return xScale( d[0]  )} )
                .attr("y", function(d) { return yScale(d[1])} )

    }

    return allcont
}

function ordermag(val){
    var exp=Math.round(Math.log(Math.abs(val))/Math.LN10-2),
        sign = val/Math.abs(val)

    return [Math.abs(val)/Math.pow(10, exp ), exp, sign]
}

function toOrdermag(val,ord){

    return Math.round(val/Math.pow(10,ord))*Math.pow(10,ord)
}

function cont2str(conts,decs){

    var lbl=0,
        strconts=[];

    for (var i=0;i<conts.length;i++){
        lbl = parseFloat(conts[i]);


        if ((Math.abs(lbl) > 100) || (Math.abs(lbl) < 0.01)){
          lbl=lbl.toExponential(1)
          

        }else if (lbl == Math.round(lbl)){
            lbl=lbl.toFixed(0)

        }else{
            lbl=lbl.toFixed(decs)
        }

        strconts.push(lbl)
    }
    return strconts
}

            
function find_conts(m,M,num_cont){            
  
  // finds convenient as round as possible contour values
      
        var om=ordermag(M-m),
            retom

        
        if (om[1] <= -2){
            var cont_step=(M-m)/num_cont

    //        console.log(m+'..'+M+'..'+cont_step)
      
            return {range:d3.range(m,M,cont_step) , om:1}

        }

        var dMM=om[0],
            omag=om[1],
            mm=toOrdermag(m,omag),
            MM=toOrdermag(M,omag),

     //       cont_step=toOrdermag(Math.round( (MM-mm)/num_cont ),omag)

           // This is a hack! to be fixed.

           cont_step=toOrdermag(Math.round( (MM-mm)/num_cont ),omag) 
           if (cont_step==0){
               cont_step=(M-m)/num_cont
           }

    //        cont_step=toOrdermag( (M-m)/num_cont ,om)

        console.log('omag '+omag + '  num_cont: ' + num_cont)
        console.log('baba ' + mm + '.. ' + dMM + ' .. '+MM + '.. ' + cont_step)
//        console.log('yaga ' + Math.floor(mm) + '.. ' + dMM + ' .. '+Math.ceil(MM) + '.. ' + cont_step)

        if (omag >2 || omag<-2){
            
            retom=Math.pow(10,-omag)
        }else{
            retom=1. 
        }

            
        return {range:d3.range(Math.floor(mm),Math.ceil(MM),cont_step) , om:retom}


}


function make_cmap(map_name,m,M,num_cont){
    
    if (map_name == 'W'){
        return function (d){

            if (isNaN(d)){
                return 'black'
            }else{
                return 'white'
            }
        }
    }

    if (num_cont==0){
        var cmap = cmaps[map_name],
            step,
            zs_set;
      
        if (m<0 && M>0 && map_name=='BWR'){
            step = -2*m/(cmap.length-1)
            var step2=2*M/(cmap.length-1)
            zs_set = d3.range(m,0. ,step).concat(d3.range(0.,M  ,step2).concat([parseFloat(M)]));
  //          console.log(0.1*step2)
  //          console.log(d3.range(0.,M  ,step2).concat([parseFloat(M)]) )
        }else{
            step = (M - m)/ (cmap.length )
            zs_set = d3.range(m,M ,step);
        }

  //      zs_set=[parseFloat(10*m)].concat( zs_set)
  //      cmap = ['black'].concat(cmap)
        return d3.scale.linear().domain(zs_set).range(cmap);
    }
    else{


        var linmap=make_cmap(map_name,m,M,0);
    
        var zs_set=find_conts(m,M,num_cont).range,
            imzs=[];

        
        for (var i=0;i<zs_set.length;i++){

            imzs.push(linmap(zs_set[i]))
        }
 
        var mapf=d3.scale.quantize().domain([m,M]).range(imzs);

        return function (d){

            if (isNaN(d)){
                return 'grey'
            }else{
                return mapf(d)
            }
        }
    }
};
 

function get_grid(data){
 
    var ycoord = data.grid.members[0].value 
    var xcoord = data.grid.members[1].value

    for (var i=0;i<xcoord.length;i++){
        xcoord[i] = xcoord[i] - 90.
    }

    var spacingX = xcoord[1] - xcoord[0];
    var spacingY = ycoord[1] - ycoord[0];
   
    var maxY = ycoord[ycoord.length-1]
    var minY = ycoord[0]

    var maxX = xcoord[xcoord.length-1]
    var minX = xcoord[0]

    console.log("spacingX: " + spacingX +"  spacingY: "+spacingY)

    console.log("Mx = "+maxX+"  mx = "+minX+"  My = "+maxY+"  my = "+minY + " => " +(maxX-minX)/spacingX+":"+(maxY-minY)/spacingY);

    console.log('Length of data is '+data.value.length)
    var new_data = prepare_data(data, xcoord, ycoord);

    var grid = make_grid(new_data, maxX, minX, maxY, minY, spacingX, spacingY)
 

    return {grid:grid, maxX:maxX,minX:minX, maxY:maxY, minY:minY   }
}

function make_grid(data, maxX, minX, maxY, minY, spacingX, spacingY){

 

    // The data is provided as an array of [lat, lon, value] arrays and it need to be mapped to a grid.
    // Determine the min and max latitudes and longitudes
 
   
    var grid_len_x = Math.round( (maxX-minX)/spacingX+1 )
    var grid_len_y = Math.round( (maxY-minY)/spacingY+1 )
    console.log("grid len X: " + grid_len_x)
     

    // Create a properly dimensioned array
    var grid=new Array( grid_len_x);

 
    for (var i=0;i<grid.length;i++)
        grid[i] = Array( grid_len_y );
            
    
    // Fill the grid with the values from the data array
    data.forEach(function(val){grid[Math.round((val[1]-minX)/spacingX)][Math.round( (val[0]-minY)/spacingY ) ]=val[2];});
            
    //Add a "cliff edge" to force contour lines to close along the border.          
    grid = make_cliff(grid);

   
   
    return grid
}

function make_cliff(grid){

    var cliff = -400;
    grid.push(d3.range(grid[0].length).map(function() { return cliff; }));
    grid.unshift(d3.range(grid[0].length).map(function() { return cliff; }));
    grid.forEach(function(nd) {
        nd.push(cliff);
        nd.unshift(cliff);
    });
   
    return grid
}

function data2xyvalue(data,xcoord,ycoord){
    // Returns a 2D grid as one array of 3-tuples of (y,x,value)
    //

    new_data = []
    for (var j=0;j<data.length;j++){
                        
        var row = data[j];
        for (var i=0;i<row.length;i++){
            var new_item = [ycoord[j],xcoord[i],row[i]]

            new_data.push(new_item)
        }
    }
return new_data;
}


function data2rectangles(data,xScale,yScale){
    // Takes a 2D grid and returns one array of 5-tuples of (y,x,dy,dx,value). Coords in xScale and yScale
    // to be used to draw rectangles, with x,y the upper left corner and dy,dx the widths.


    var ycoord_edges=data.coord0_edges,
        xcoord_edges=data.coord1_edges;
     
  
    new_data = []
    for (var j=0;j<data.value.length;j++){
                        
        var row = data.value[j];
        for (var i=0;i<row.length;i++){
            var new_item = [yScale(ycoord_edges[j+1]),xScale(xcoord_edges[i]),Math.ceil(yScale(ycoord_edges[j])-yScale(ycoord_edges[j+1])),Math.ceil(xScale(xcoord_edges[j+1])-xScale(xcoord_edges[j]) ),row[i]]

            new_data.push(new_item)
        }
    }
return new_data;
}

        </script>

    </body>
</html>

