<!DOCTYPE html>
{% load static %}


<html lang="en">
    <head>
        
        <meta charset="utf-8" name="viewport" content="initial-scale=1.0, user-scalable=no"/>
  
  <!--      
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
 <script type="text/javascript" src="https://raw.github.com/jasondavies/conrec.js/master/conrec.js"></script>
	<script src="https://raw.github.com/d3/d3-plugins/master/geom/contour/contour.js"></script>
 -->

        <script src="{% static "js/d3.v3.min.js" %}">  </script> 
        <script src="{% static "js/conrec.js" %}">  </script>
        <script src="{% static "js/contour.js" %}">  </script> 
        <script src="{% static "js/jquery-2.1.1.min.js" %}">  </script>

        <style type="text/css">
            h1 {
            	font-family: sans-serif;
            	color: lime;
            }
        </style>

        <style type="text/css">
            .my_axis path,
            .my_axis line {
                fill: none;
                stroke: black;
                shape-rendering: crispEdges;
            }

            .my_axis text {
                font-family: sans-serif;
                font-size: 11px;
            }

            .my_colorbar text {
                font-family: sans-serif;
                font-size: 11px;
            }


            .my_flabel text {
                font-family: sans-serif;
                font-size: 13px;
            }

            .my_clabel text {
                font-family: sans-serif;
                font-size: 12px;
            }
      
.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}      
        </style>

        <title>This is my page</title>
    
    </head>
    <body>
        <h1>Data </h1>
   
 
    
        <script type="text/javascript">

                    var w=500,
                        h=300,
                        wcb=50,
                        padding=40;

                      
                    var div=d3.select("body")
                              .append("div")
                              .attr("id","yo")
                    var svg=div.append("svg")
                                  .attr("width",w)
                                  .attr("height",h)
                                  .attr("id","yo_svg")
                    div.append("button")
                       .attr("id","but1")
                    .text("data")
    //                .on("click",function(d){url=prep_url('A_sat');d3.json(url,function(data){handle_data(div,data,url)})})

                    .on("click",function(d){url=prep_url('O_temp/ops/?ops=MeanX');d3.json(url,function(data){handle_data(div,data,url)})})



function handle_more_data(axob,data){

    data.value = handle_nan(data.value);
    data.lname =''


    var w=svg.attr("width")
    var h=svg.attr("height")
 
    var wcb=50,
        padding=40;
     
    return plot_contour(axob.svg,d3.transpose(data.value),data.coord0,data.coord1,axob.xScale,axob.yScale,data.m,data.M,12, false, true);
}

function handle_data(div,data,url){
    
    svg=div.selectAll("svg")
    data.value = handle_nan(data.value);
    
    var w=svg.attr("width")
    var h=svg.attr("height")
 
    var wcb=50,
    padding=40;

    // calculate scales
    axob=prep_axes(svg, data,padding,wcb,true,true,-1)

    elms=my_plot(axob,data)



// element w=handle_more_data(axob,data) is removed again with w.remove()

addtoggle(axob,data,div,"button",handle_more_data,"conts off","conts")

d3.json(prep_url('G_kmt'),function(data){addtoggle(axob,data,div,"button",my_kmt,"geog off","geography")})


d3.json(prep_url('O_psi'),function(data){addtoggle(axob,data,div,"button",handle_more_data,"psi off","psi")})


    return elms

}



function toggle(w,axob,data,but,func,onms,offms){

    if (w==false){
        but.text(onms)
        return func(axob,data);
    }else{
        w.remove()
        but.text(offms)
        return false
    }    
};

function addtoggle(axob,data,div,tag,func,onms,offms){

    var w,
        but 
    // data available in namespace
 //   var offms="contours",
 //       onms="remove conts";
    but=div.append(tag)
    but.attr("id",onms+offms)
        .text(offms)
        .on("click",function(d){
            // need to wrap toggle var w inside here:
            w=toggle(false,axob,data,but,func,onms,offms)
            
            but.on("click",function(d){
                w=toggle(w,axob,data,but,func,onms,offms)   
            });
         })

}




function my_kmt(axob,data){

    data.value = handle_nan(data.value);
    data.lname =''


    var w=axob.svg.attr("width")
    var h=axob.svg.attr("height")
 
    var wcb=50,
        padding=40;
     
    return plot_contour(axob.svg,d3.transpose(data.value),data.coord0,data.coord1,axob.xScale,axob.yScale,data.m,data.M,12, [0.5], false);
};






function my_plot(axob,data){
 
    tuples = data2rectangles(data,axob.xScale,axob.yScale)

    var pclr=pcolor(axob.svg,tuples,data.m,data.M,24)

     //       svg = plot_contour(svg,d3.transpose(data.value),data.coord0,data.coord1,axob.xScale,axob.yScale,data.m,data.M,12, false, true);

    axob.svg.append("ClipPath")
        .attr("id", "p-area")
        .append("rect")
        .attr("x",axob.padding)
        .attr("y",axob.padding)
        .attr("w", w-axob.padding-axob.wcb)
        .attr("height",h-axob.padding)

    var cbar=colorbar(axob.svg,data.m,data.M,30, axob.wcb,axob.padding,data.units,colours);

        

    //          plot(svg,data.value, ycoord,true,true,units,xlabel,ylabel,title,-1)

    return [pclr,cbar]             
};





        </script>

        
<script type="text/javascript">
 


function plot(svg,data, xcoord,xax,yax,units,xlabel,ylabel,title,i){
    // expects data to be either an array of numbers
    // or an array of such arrays (multiple curves)

    if (data[0].length == undefined){
        data=[data];
        xcoord=[xcoord];
    }

    // use nested max/ min as per mbostock answer on stackoverflow
    var My = d3.max(data.map(function(array) {
  return d3.max(array);
}));

    var my = d3.min(data.map(function(array) {
  return d3.min(array);
}));

    var Mx = d3.max(xcoord.map(function(array) {
  return d3.max(array);
}));

    var mx = d3.min(xcoord.map(function(array) {
  return d3.min(array);
}));



    console.log( 'mx and Mx: ' + mx + ' ' + Mx)

    var w=svg.attr("width")
    var h=svg.attr("height")
 

    var lineData = [],
        lines = [],
        xc,
        yc     
 

    for (var j=0;j<data.length;j++){
        lineData = []
        xc=xcoord[j]
        yc=data[j]
        for (var i=0;i<yc.length;i++){
            
            lineData.push({x:xc[i],y:yc[i]})
            lines.push(lineData)


        }
    }

var vis = svg,
    WIDTH = w,
    HEIGHT = h,
    MARGINS = {
      top: 30,
      right: 20,
      bottom: 30,
      left: 50
    },
    xRange = d3.scale.linear().range([MARGINS.left, WIDTH - MARGINS.right]).domain([mx,Mx]),
    yRange = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([my, My]),
    xAxis = d3.svg.axis()
      .scale(xRange)
      .tickSize(5)
      .tickSubdivide(true),
    yAxis = d3.svg.axis()
      .scale(yRange)
      .tickSize(5)
      .orient('left')
      .tickSubdivide(true);
 
vis.append('svg:g')
  .attr('class', 'x axis')
  .attr("class", "my_axis")
  .attr('transform', 'translate(0,' + (HEIGHT - MARGINS.bottom) + ')')
  .call(xAxis);

 
vis.append('svg:g')
  .attr('class', 'y axis')
  .attr("class", "my_axis")
  .attr('transform', 'translate(' + (MARGINS.left) + ',0)')
  .call(yAxis);
    

vis.append("g")
  .attr("class", "my_flabel")
      .append("text")
      .attr("class", "y label")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("x", -26)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(ylabel);

vis.append("g")
  .attr("class", "my_flabel")
.append("text")
      .attr("class", "x label")
      .attr("class", "my_axis")
      .attr("text-anchor", "end")
      .attr("x", WIDTH- MARGINS.right)
      .attr("y", HEIGHT )
      .text(xlabel);


 // line plotting

// function used to draw lines
var lineFunc = d3.svg.line()
  .x(function(d) {
    return xRange(d.x);
  })
  .y(function(d) {
    return yRange(d.y);
  })
  .interpolate('linear');

// plot one or more lines, using lineFunc
for  (var i=0;i<lines.length;i++){
    
    vis.append('svg:path')
      .attr('class', 'line')
      .attr('d', lineFunc(lines[i]))
   
    }
}









function plot2(svg,data, xcoord){
    // from mbostok github. not working yet

    // expects data to be either an array of numbers
    // or an array of such arrays (multiple curves)

    if (data[0].length == undefined){
        data=[data];
        xcoord=[xcoord];
    }

    var lineData = [],
        lines = [],
        xc,
        yc     
 
    for (var j=0;j<data.length;j++){
        lineData = []
        xc=xcoord[j]
        yc=data[j]
        for (var i=0;i<yc.length;i++){
            
            lineData.push({x:xc[i],y:yc[i]})
        lines.push(lineData)

        }
    }

    var w=svg.attr("width")
    var h=svg.attr("height")
 
var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = w - margin.left - margin.right,
    height = h - margin.top - margin.bottom;

var x = d3.scale.linear()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");


var line = d3.svg.line()
    .x(function(d) { return x(d.x); })
    .y(function(d) { return y(d.y); });

var linesvg = svg.append("g")
    
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//d3.tsv("data.tsv", function(error, data) {
//  data.forEach(function(d) {
//    d.date = parseDate(d.date);
//    d.close = +d.close;
//  });

  x.domain(d3.extent(data, function(d) { return d.x; }));
  y.domain(d3.extent(data, function(d) { return d.y; }));

  linesvg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  linesvg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("y label");

// 
  for  (var i=0;i<lines.length;i++){

    linesvg.append("path")
        .datum(lines[i])
        .attr("class", "line")
        .attr("d", line);

}

//});

}

















function handle_nan(value){

    var row
    for (i=0;i<value.length;i++){
        row=value[i]
        for (j=0;j<row.length;j++){
            if (row[j] < -8e20){
   
   // this needs to be some other value for d3.max and d3.min to work.
                row[j] = NaN
            }
        }
    }

    return value
}

function prep_url(varname){
    return '/sgdata/my_project/DPO/' + varname
}


//svg, data.coord0_edges,data.coord1_edges,data.m,data.M,padding,wcb,true,true,data.units,data.coord1_lname,data.coord0_lname,data.lname,-1

function prep_axes(svg, data,padding,wcb,xax,yax,i){


    var ycoord_edges=data.coord0_edges,
        xcoord_edges=data.coord1_edges,
        m=data.m,
        M=data.M,
        units=data.units,
        xlabel=data.coord1_lname,    
        ylabel=data.coord0_lname,
        title=data.lname;

    var w=svg.attr("width"),
        h=svg.attr("height");
        
if (i >-1){
    title =  ' ('+String.fromCharCode(97+i) +') '+title

}

hylabel=svg.append("g")
  .attr("class", "my_flabel")
      .append("text")
      .attr("class", "y label")
      .attr("transform", "rotate(-90)")
      .attr("y", 0)
      .attr("x", -Math.round((h-padding)/2))
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(ylabel);

hxlabel=svg.append("g")
  .attr("class", "my_flabel")
.append("text")
      .attr("class", "x label")
      .attr("class", "my_axis")
      .attr("text-anchor", "end")
      .attr("x", Math.round((w  )/2 ) )
      .attr("y", h-6 )
      .text(xlabel);

htitle=svg.append("g")
  .attr("class", "my_flabel")
.append("text")
//      .attr("class", "x label")
      .attr("class", "my_axis")
      .attr("text-anchor", "start")
      .attr("x", padding  )
      .attr("y", 25 )
      .text(title);



    // contains array of (y,x,dy,dx,value)

 //    colours = make_cmap('standard',m,M,num_cont);

    var size_y = ycoord_edges.length-1,
        size_x = xcoord_edges.length-1
    
    
    var xpadding = 0,
        ypadding = 0,
        cellw = w/size_x - xpadding,
        cellh = h/size_y - ypadding


    var xScale = d3.scale.linear()
                         .domain([xcoord_edges[0], xcoord_edges[xcoord_edges.length-1]])
                         .range([padding, w-padding-wcb]);

    var yScale = d3.scale.linear()
                         .domain([ycoord_edges[0], ycoord_edges[ycoord_edges.length-1]])
                         .range([h-padding, padding]);                         

    if (xax){
        var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .orient("bottom");

        svg.append("g")
           .attr("class", "my_axis")
           .attr("transform","translate(0," + (h - padding) + ")")
           .call(xAxis);              
    }

    if (yax){
        var yAxis = d3.svg.axis()
                      .scale(yScale)
                      .orient("left");

        svg.append("g")
           .attr("class", "my_axis")
           .attr("transform", "translate(" + padding + ",0)")
           .call(yAxis);      
    }

    axob={svg:svg,xScale:xScale,yScale:yScale,wcb:wcb,padding:padding,hxlabel:hxlabel,hylabel:hylabel,htitle:htitle,i:i}

    return axob
}



function pcolor(svg,tuples,m,M,num_cont){


    colours = make_cmap('standard',m,M,num_cont);
    

 //   var yScaleWidth = d3.scale.linear()
 //                        .domain([ycoord_edges[0], ycoord_edges[ycoord_edges.length-1]])
 //                        .range([-h/2, h/2]);   

    // plot the pcolor
    pclr = svg.append("g")
              .attr("class","my_pcolor")
              .selectAll("rect").data(tuples)
                         .enter()
                         .append("rect")
                         .attr("x", function(d){return d[1] })
                         .attr("y", function(d){return d[0] })
                         .attr("width", function(d){return d[3] })
                         .attr("height",function(d){return d[2] })

                         .attr("fill", function(d) { return colours(d[4]);});


 

    return pclr   
}

function colorbar(svg,m,M,boxes,wcb,padding,units,colours){

    if (wcb==0){
        return
    }

    var w=svg.attr("width"),   
        h=svg.attr("height"),
        bh = h/boxes,
//        cstep = (M-m)/boxes,
//        zs = d3.range(m,M,cstep),

        contl=find_conts(m,M,boxes)
        zs=contl.range,
        zs_str=cont2str(zs,1),
        from_fig = 5,
        from_bar =3,
        portion = 0.4,
        yticks = 6,
        axpos=w-padding,
        modulus = Math.round(boxes/yticks)
  
  
    var yScale=d3.scale.ordinal()
                  .domain(d3.range(zs.length)  )
                  .rangeRoundBands([h-padding,padding],0.01);

// 0.6 portion for text
    var cbar = svg.append("g")
                  .attr("class", "my_colorbar")

    var body=cbar.append("g")       
       .selectAll("rect")
       .data(zs)
       .enter()
       .append("rect")
       .attr("x", w-wcb-padding + from_fig)
       .attr("y", function(d,i){return yScale(i)})
       .attr("width",portion*wcb)
       .attr("height",yScale.rangeBand())
       .attr("fill", function(d){return colours(d)})

  //      var yAxis = d3.svg.axis()
 //                     .scale(yScale)
 //                     .orient("right");

 //       svg.append("g")
 //          .attr("class", "my_axis")
 //          .attr("transform", "translate(" + axpos + ",0)")
 //          .call(yAxis);      

       
    
    var labels = cbar.append("g")
       .attr("class", "my_colorbar")
       .selectAll("text")
       .data(zs)
       .enter()
       .append("text")
       .text(function(d,i){
            if (i%modulus == 0){return cont2str([contl.om*d],1)[0]} return ''
       })
       .attr("x", w -(1-portion)*wcb -padding + from_fig +from_bar)
       .attr("y", function(d,i){return yScale(i)})

    if (units !='h'){
        cbar.append("g")
          .attr("class", "my_flabel")
              .append("text")
              .attr("class", "y label")
              .attr("transform", "rotate(-90)")
              .attr("y", w-padding+8)
              .attr("x", -Math.round((h-padding)/2))
              .attr("dy", ".71em")
              .style("text-anchor", "end")
              .text(units);
}

       
    return cbar
    
}



function plot_contour(svg,data,ycoord,xcoord,xScale,yScale,m,M, num_cont, conts, labels ){
 
     // d3 employs chain syntax. Example: d3.select("body").append("p").text("New paragraph!");

     // .select("body") â€” Give select() a CSS selector as input, and it will return a reference to the first element in the DOM that matches.
     // append(), in turn, hands down a reference to the new element it just created.
     //  .text puts the text inside the tags of the DOM element just handed to it.

     // Typically, a method returns a reference to the element that it just acted upon, but not always. 


    // d3.range creates an array [a1,a2,...] of values for zs much like Python arange 

    // scales are functions that map from an input domain to an output range.
    // The scale has additional methods that change its behavior. 
    // A scale object, such as that returned by d3.scale.linear, is both an object and a function. 

    // Like other classes in D3, scales follow the method chaining pattern where setter methods return the scale itself.


    console.log(xcoord[0])
    var w=svg.attr("width")
    var h=svg.attr("height")
    
    // initialize Conrec object with specific data
    var c = new Conrec(),
        zs,
        om
    
    if ( conts == false){
        contl=find_conts(m,M,num_cont)
        console.log(contl.om)
        zs=cont2str(contl.range,1)
        om=contl.om

     //   cont_step = (M-m)/num_cont;
     //   zs = d3.range(m , M , cont_step);       
    }else{
     
        zs=conts;
        om=1.
    }
 
    // call contour method on existing Conrec object
    c.contour(data, 0, xcoord.length-1, 0, ycoord.length-1, xcoord, ycoord, zs.length, zs);
   
    // nesting the c.contourList() according to level and feed as data to d3

    nested = d3.nest().key(function(d) { return d.level}).entries(c.contourList())

    // created contour labels
    var lbpos = [],
        cont_i1 = 0,
        lbl;
    //    cont_i2 = 0;

    
    for (var i=0;i<nested.length;i++){
        for (var j=0;j<nested[i].values.length;j++){
            cont_i1 =  Math.floor((nested[i].values[j].length)*Math.random() )
    //        cont_i2 = Math.round(nested[i].values[j].length*3/4)

            lbl = om*parseFloat(nested[i].key )
            if (lbl == Math.round(lbl)){
                lbl=lbl.toFixed(0)

            }else{
                lbl=lbl.toFixed(1)
            }

            lbpos.push( [nested[i].values[j][cont_i1].x,nested[i].values[j][cont_i1].y,  lbl    ]  )

        }
    }
    
    var allcont = svg.append("g")  
    
    var contplot = allcont.append("g")
        .attr("class","my_contplot")
        .selectAll("g")
        .data( nested )
        .enter()
        .append("svg:g")  // due to nesting, key is now the level
            .attr("class",function(d) { return "level_"+d.key})
    //        .style("fill",function(d) { console.log(d.key);return colours(d.key);})
   //         .style("fill",function(d) { return colours(d.key);}) 
            .style("fill","none")                       
            .style("stroke","black")
            .style("opacity",0.5)


    var conts = contplot.append("g")
                .selectAll("path")
                .data(function(d) { return d.values}) // note function in data method
                .enter()
          
                .append("svg:path")
                    .attr("d",d3.svg.line()  // this function is an iterator!
                        .x(function(d) { return xScale(d.x)})
                        .y(function(d) { return yScale(d.y)})
                        )


    if (labels){
        var clabels = allcont.append("g")
                .attr("class","my_clabel")
                .attr("clip-path","url(#p-area)")
                .selectAll("text")
                .data(lbpos) // note function in data method
                .enter()          
                .append("text")
               
                .text(function(d,i){
                  return d[2] })
                .attr("x", function(d) { return xScale( d[0]  )} )
                .attr("y", function(d) { return yScale(d[1])} )

    }

    return allcont
}

function ordermag(val){
    var exp=Math.round(Math.log(Math.abs(val))/Math.LN10-2),
        sign = val/Math.abs(val)

    return [Math.abs(val)/Math.pow(10, exp ), exp, sign]
}

function toOrdermag(val,ord){

    return Math.round(val/Math.pow(10,ord))*Math.pow(10,ord)
}

function cont2str(conts,decs){

    var lbl=0,
        strconts=[];

    for (i=0;i<conts.length;i++){
        lbl = parseFloat(conts[i]);
        if (lbl == Math.round(lbl)){
            lbl=lbl.toFixed(0)

        }else{
            lbl=lbl.toFixed(decs)
        }
        strconts.push(lbl)
    }
    return strconts

}


            
function find_conts(m,M,num_cont){            
  
  // finds convenient as round as possible contour values
      
        var om=ordermag(M-m),
            retom

        if (om[1] == -2){
            var cont_step=(M-m)/num_cont

    //        console.log(d3.range(m,M,cont_step))
            return d3.range(m,M,cont_step)
        }

        var dMM=om[0],
            omag=om[1],
            mm=toOrdermag(m,omag),
            MM=toOrdermag(M,omag),

     //       cont_step=toOrdermag(Math.round( (MM-mm)/num_cont ),omag)

           cont_step=toOrdermag(Math.round( (MM-mm)/num_cont ),omag)

    //        cont_step=toOrdermag( (M-m)/num_cont ,om)

        console.log('omag '+omag + '  num_cont: ' + num_cont)
//        console.log('baba ' + mm + '.. ' + dMM + ' .. '+MM + '.. ' + cont_step)
//        console.log('yaga ' + Math.floor(mm) + '.. ' + dMM + ' .. '+Math.ceil(MM) + '.. ' + cont_step)

        if (omag >2 || omag<-2){
            
            retom=Math.pow(10,-omag)
        }else{
            retom=1. 
        }

            
        return {range:d3.range(Math.floor(mm),Math.ceil(MM),cont_step) , om:retom}


}


cmaps = {standard:['#000099','#0000FF','#3399FF','#00CCFF','#00CC00','#66FF00','#FFFF00','#CC0000','#FF6633'], BWR:['blue','white','red']}

function make_cmap(map_name,m,M,num_cont){
    
    if (num_cont==0){
        var cmap = cmaps[map_name],
            step = (M - m)/ (cmap.length - 1),
            zs_set = d3.range(m,M ,step);
      
        return d3.scale.linear().domain(zs_set).range(cmap);
    }
    else{


        var linmap=make_cmap(map_name,m,M,0);
    
        var    zs_set=find_conts(m,M,num_cont).range,
            imzs=[];

        
        for (var i=0;i<zs_set.length;i++){

            imzs.push(linmap(zs_set[i]))
        }
        
        return d3.scale.quantize().domain([m,M]).range(imzs);
    }


};
 

function get_grid(data){
 
    var ycoord = data.grid.members[0].value 
    var xcoord = data.grid.members[1].value

    for (i=0;i<xcoord.length;i++){
        xcoord[i] = xcoord[i] - 90.
    }

    var spacingX = xcoord[1] - xcoord[0];
    var spacingY = ycoord[1] - ycoord[0];
   
    var maxY = ycoord[ycoord.length-1]
    var minY = ycoord[0]

    var maxX = xcoord[xcoord.length-1]
    var minX = xcoord[0]

    console.log("spacingX: " + spacingX +"  spacingY: "+spacingY)

    console.log("Mx = "+maxX+"  mx = "+minX+"  My = "+maxY+"  my = "+minY + " => " +(maxX-minX)/spacingX+":"+(maxY-minY)/spacingY);

    console.log('Length of data is '+data.value.length)
    var new_data = prepare_data(data, xcoord, ycoord);

    var grid = make_grid(new_data, maxX, minX, maxY, minY, spacingX, spacingY)
 

    return {grid:grid, maxX:maxX,minX:minX, maxY:maxY, minY:minY   }
}

function make_grid(data, maxX, minX, maxY, minY, spacingX, spacingY){

 

    // The data is provided as an array of [lat, lon, value] arrays and it need to be mapped to a grid.
    // Determine the min and max latitudes and longitudes
 
   
    var grid_len_x = Math.round( (maxX-minX)/spacingX+1 )
    var grid_len_y = Math.round( (maxY-minY)/spacingY+1 )
    console.log("grid len X: " + grid_len_x)
     

    // Create a properly dimensioned array
    var grid=new Array( grid_len_x);

 
    for (var i=0;i<grid.length;i++)
        grid[i] = Array( grid_len_y );
            
    
    // Fill the grid with the values from the data array
    data.forEach(function(val){grid[Math.round((val[1]-minX)/spacingX)][Math.round( (val[0]-minY)/spacingY ) ]=val[2];});
            
    //Add a "cliff edge" to force contour lines to close along the border.          
    grid = make_cliff(grid);

   
   
    return grid
}

function make_cliff(grid){

    var cliff = -400;
    grid.push(d3.range(grid[0].length).map(function() { return cliff; }));
    grid.unshift(d3.range(grid[0].length).map(function() { return cliff; }));
    grid.forEach(function(nd) {
        nd.push(cliff);
        nd.unshift(cliff);
    });
   
    return grid
}

function data2xyvalue(data,xcoord,ycoord){
    // Returns a 2D grid as one array of 3-tuples of (y,x,value)
    //

    new_data = []
    for (var j=0;j<data.length;j++){
                        
        var row = data[j];
        for (var i=0;i<row.length;i++){
            var new_item = [ycoord[j],xcoord[i],row[i]]

            new_data.push(new_item)
        }
    }
return new_data;
}

function data2rectangles(data,xScale,yScale){
    // Returns a 2D grid as one array of 5-tuples of (y,x,dy,dx,value) 
    // to be used to draw rectangles, with x,y the upper left corner and dy,dx the widths.


    var ycoord_edges=data.coord0_edges,
        xcoord_edges=data.coord1_edges;
     

    new_data = []
    for (var j=0;j<data.value.length;j++){
                        
        var row = data.value[j];
        for (var i=0;i<row.length;i++){
            var new_item = [yScale(ycoord_edges[j+1]),xScale(xcoord_edges[i]),Math.ceil(yScale(ycoord_edges[j])-yScale(ycoord_edges[j+1])+0.2),Math.ceil(xScale(xcoord_edges[j+1])-xScale(xcoord_edges[j]) +0.2 ),row[i]]

            new_data.push(new_item)
        }
    }
return new_data;
}

        </script>

    </body>
</html>

